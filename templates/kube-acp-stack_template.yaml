---
# Source: kube-acp-stack/charts/cockroachdb/templates/poddisruptionbudget.yaml
kind: PodDisruptionBudget
apiVersion: policy/v1
metadata:
  name: cockroachdb-budget
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: cockroachdb
      app.kubernetes.io/instance: "release-name"
      app.kubernetes.io/component: cockroachdb
  maxUnavailable: 1
---
# Source: kube-acp-stack/charts/acp/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/serviceaccount-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: ServiceAccount
metadata:
  name: timescaledb
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: rbac
---
# Source: kube-acp-stack/charts/acp/templates/secretconfig.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
stringData:
  config.yaml: |
    redis:
      password: p@ssw0rd!
    timescale:
      url: postgres://postgres:PaSsW0rD@timescaledb/postgres
---
# Source: kube-acp-stack/charts/acp/templates/tls-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-acp-tls
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVEakNDQXZhZ0F3SUJBZ0lVRkxVR2IrVXgzTGJ5VEFkUDNac2t0MGlDYlFJd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1Z6RUxNQWtHQTFVRUJoTUNWVk14RXpBUkJnTlZCQWdUQ2xkaGMyaHBibWQwYjI0eEVEQU9CZ05WQkFjVApCMU5sWVhSMGJHVXhGREFTQmdOVkJBb1RDME5zYjNWa1pXNTBhWFI1TVFzd0NRWURWUVFMRXdKRFFUQWVGdzB5Ck1UQTBNakl3TnpRMk1EQmFGdzB5TmpBME1qRXdOelEyTURCYU1IY3hDekFKQmdOVkJBWVRBbFZUTVJRd0VnWUQKVlFRSUV3dFhZWE5vYVc1bmFIUnZiakVRTUE0R0ExVUVCeE1IVTJWaGRIUnNaVEVVTUJJR0ExVUVDaE1MUTJ4dgpkV1JsYm5ScGRIa3hGakFVQmdOVkJBc1REVUYxZEdodmNtbDZZWFJwYjI0eEVqQVFCZ05WQkFNVENXRmpjQzVzCmIyTmhiRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFLM0wxRzdWS080YURhY3cKREdBNklPbmNUZ1QwaklVbHRTK09TTEg5a2U1bHRMZklLWitiamRNWWp2N0xUOXhPSDlWOWxJNUhSTXRNeGJoRAptTFl5OStkeWJXTEIxNW1jeG0rejNscnVoQk1QUy9aeGNHdkRkWlFJTGwzQ1VmM3o2SmZKRnQ3YzNjWHNKZmN1CnZCb1FKY1RDb0s3UjFmQTFSUGVDS0lUQU1jQ0UrT2FiNjdtUWhaREM3TkxjbUowVU9SS2FlVmhuMmdocGlVSU0KaVArdWhkQ2FBR3M2ODNQNkFvaDBOMXoxenNmcmM2cEpMbTQ0STZFOGNZVVN0MEtoNGdDOEs0aXZKaURFcFpVVgpPNlZGRnpiR0xwbURKdFE3c3ljUUNUSzlYbklDK0pMREJpOHRKTC9KbGtFekk4VDdGRFFucmFWRXBJKzNYdktpCldpbktsWlVDQXdFQUFhT0JzVENCcmpBT0JnTlZIUThCQWY4RUJBTUNCYUF3SFFZRFZSMGxCQll3RkFZSUt3WUIKQlFVSEF3RUdDQ3NHQVFVRkJ3TUNNQXdHQTFVZEV3RUIvd1FDTUFBd0hRWURWUjBPQkJZRUZHY1lKZDhuN0djZgpjYnZOVlpnV1BHbnFKVnFyTUI4R0ExVWRJd1FZTUJhQUZNcFpCNFJrRkVuOVE3VS9Mc1I5Tm82cFc2TnRNQzhHCkExVWRFUVFvTUNhQ0NXeHZZMkZzYUc5emRJSURZV053Z2c1aFkzQXVZV053TFhONWMzUmxiWWNFZndBQUFUQU4KQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBY20zMGZHeENXVnBSK1ZSa0Yybm1uQ3RZNmtzV1QyN2ViNVpwcHNOcwpDb0F3VDlFTWFSUlEzc3g0My9UdnZkcHh6SktjQ0htZFBMUk9nZy9MNVVNbU9NakdUNW1xY0V2RjhDaXlBVC9nCnBZMWl1d3FJYnAzc1NmbnlUaVFuR3BTekhmdlVzYU9na2NGckxrQzhsWUxMYWw3YUhTUDVPbjN5K1BNaDhtZG0KREpTS3Q5NzNWUWo4N3E0cUU5aURYZHB6ajBLNU1LUytzYk5PaU9IOElmOUkyVHFNY3F3ZHJyTGUvVlA3bWh6NgpvTmMrY3IrK3hJZDZoMWpPNzY4anEwT2lLNUcvb1FRWFpQRC93TCtUWEYwVy9kdzZGNThFd0hlUWNEL0g3d0FzCloxaFFiNTFlLytiU0p4V01vZ1RWUFRFQ2xYejBOcE1JVjlYcmN4ZmhrNzFSanc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t
  tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBcmN2VWJ0VW83aG9OcHpBTVlEb2c2ZHhPQlBTTWhTVzFMNDVJc2YyUjdtVzB0OGdwCm41dU4weGlPL3N0UDNFNGYxWDJVamtkRXkwekZ1RU9ZdGpMMzUzSnRZc0hYbVp6R2I3UGVXdTZFRXc5TDluRncKYThOMWxBZ3VYY0pSL2ZQb2w4a1czdHpkeGV3bDl5NjhHaEFseE1LZ3J0SFY4RFZFOTRJb2hNQXh3SVQ0NXB2cgp1WkNGa01MczB0eVluUlE1RXBwNVdHZmFDR21KUWd5SS82NkYwSm9BYXpyemMvb0NpSFEzWFBYT3grdHpxa2t1CmJqZ2pvVHh4aFJLM1FxSGlBTHdyaUs4bUlNU2xsUlU3cFVVWE5zWXVtWU1tMUR1ekp4QUpNcjFlY2dMNGtzTUcKTHkwa3Y4bVdRVE1qeFBzVU5DZXRwVVNrajdkZThxSmFLY3FWbFFJREFRQUJBb0lCQVFDc2dUYjRVOGZ1bmhtVApLeFA5cDNUbjYyM2RhVWJaR2haL2Y0RVVlcFlReFE3ZHBHWDhNSkJUU1hzVjJJUUtMZGxYTlBEeFVEZ3VlcU4rClJFb2QvdlVsMitSTE5CQm1Qc0NRT3o2bmp6dTFGMmZVMDhBOGxxUHNMVHFvZ2FxVW9UYnJBZ1FiYmFzTE8xeHIKdncyaDZRazBCZU1yNHNleFI0NlBCYmhtRzhiR1NSTS9GKzJsSkt3ckxkb0JhbUpCcmF4MHMzM1FYSEp6RTQwMQpNYnAwQVBTT3IvOFNsN05HZUFLNmJqQktaZ0Q2UGpDUkZ2Z1RQSDROOElYVUtjcm8yNWdscHdUOEFRQXZwQjJOCmhuVUx2R3BFbGJNRWNIWVJ6ODZNamYvN3pkSWphUngwLzNkSzg3Ym1JM01yUmVOYUp2MVUrbmUvbHNsUEppelUKbVhiVjFtQUJBb0dCQU5sOE9rSXpSSTBKbUM0RE4vUVAwRENFbVFNdkUxdmtSM3JoUlFNQ2VXUFduOEUrMTdUNApwT1crZmZLRW5UNXBhUm1acnc5WDNJNzlPRUJyVkVyWllGTmY2ZjMzRE1qQjExYnpzNktRRitOMGlmMk5sU2Y5ClJNT09yYklLZWcwK0ZSdURUeEpYMFZZK21qdzd4ZnpScTdaZyt6TFNkeVRIYnltdnRMZnlWcm1WQW9HQkFNeVMKOFgzV1NZS0xWS0VrREg0SUV6L09oZjlCdnBTN2YybFNyOVZlSzgyMFdZSkRLYlZpNVcrVXNqcjAvS1I4ZEFnUgpxSmRraTNJNFBRRXdHVDNBQmNZZzhEdjkvaGRSU3grS1Y5b0NQY3RBMXBLRzJlQWlaa1NYWWVQRFpBTlUzU053CjlTTE1GV1Q3QUVOUm1yYlNab3haaDc5YzNSQnU5U1dZYWFBc1JXd0JBb0dCQUxVdVJjYUN1VmdacHhxbCtjWXMKS2s5UkY3dk1TdjlodEo3TTdsWXNpSDVBL1lQYTI0N2JHVnlBRHFLc0VlYzluNTRCSnhMTUttVkExTXp0M1NJaAo1NXB0ckJ5ejVJV1czdE9FWUtGTUUycWMycHhOaC9YeGk0aXk0MGNRYlU5ODZjNnEzSU8yZnlHdk00UjhjMXRFClBSM0p1MXRDZEpsQ1AveGxjVk5RNHlqbEFvR0JBS1RES0lwdi93Nk1CeUl0ZFg1QUpMaThMZ0hTd3BycGxBbVEKMWhzajJHVzVmbW5DakNJUnY3WXBiWTY4WjRwV3plRDl6K24yeWJTNWhMQ2pPNEVYV2M4a0VqaFBMY2s3NlNSQworTlNWLzR6bThLcGN2N2VjSFAvYmFMVFhWb0swWTlLNmxFUnRXRUhYUW5QMWtvVHlXak5wbkVKTW1hTTFxbTJZCkhtSXBwZFFCQW9HQVViRURpdWpBVFBPOFhWRnFGUGNGcDRxSEtsV0ZFcmFCYzRUZXNrMXcxckRONnZJclQ4VmgKVTc4R21hVlRYY0dUck10OFFCdDZmRlVWYlZwdVcyQ2YvYURILzZVZWxrd3NvYlphV1F5NThkMk52ME5Ta2d1TwpEYkl1OUtSQU9QKzJUVmc4dVRZZzFZK1BxQXVBYlFBYXVZcGMrd2I0OEViTWdYeDFhMjk0ZnVJPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQ==
---
# Source: kube-acp-stack/charts/redis-cluster/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: redis-cluster
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  redis-password: "cEBzc3cwcmQh"
---
# Source: kube-acp-stack/charts/acp/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
data:
  config.yaml: |
    server:
      url: https://acp.local:8443
      certificate:
        cert_path: "/tls/tls.crt"
        key_path: "/tls/tls.key"
      port: 8443
      client_certificate_header: "X-SSL-CERT"
    sql:
      url: postgres://root@cockroachdb-public:26257/defaultdb?sslmode=disable
    timescale:
      enabled: true
    redis:
      addrs:
      - redis-cluster-headless:6379
      - redis-cluster-headless:6379
      redis_search: true
  extraconfig.yaml: |
---
# Source: kube-acp-stack/charts/redis-cluster/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-cluster-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
data:
  redis-default.conf: |-
    # Redis configuration file example.
    #
    # Note that in order to read the configuration file, Redis must be
    # started with the file path as first argument:
    #
    # ./redis-server /path/to/redis.conf

    # Note on units: when memory size is needed, it is possible to specify
    # it in the usual form of 1k 5GB 4M and so forth:
    #
    # 1k => 1000 bytes
    # 1kb => 1024 bytes
    # 1m => 1000000 bytes
    # 1mb => 1024*1024 bytes
    # 1g => 1000000000 bytes
    # 1gb => 1024*1024*1024 bytes
    #
    # units are case insensitive so 1GB 1Gb 1gB are all the same.

    ################################## INCLUDES ###################################

    # Include one or more other config files here.  This is useful if you
    # have a standard template that goes to all Redis servers but also need
    # to customize a few per-server settings.  Include files can include
    # other files, so use this wisely.
    #
    # Notice option "include" won't be rewritten by command "CONFIG REWRITE"
    # from admin or Redis Sentinel. Since Redis always uses the last processed
    # line as value of a configuration directive, you'd better put includes
    # at the beginning of this file to avoid overwriting config change at runtime.
    #
    # If instead you are interested in using includes to override configuration
    # options, it is better to use include as the last line.
    #
    # include /path/to/local.conf
    # include /path/to/other.conf

    ################################## MODULES #####################################

    # Load modules at startup. If the server is not able to load modules
    # it will abort. It is possible to use multiple loadmodule directives.
    #
    # loadmodule /path/to/my_module.so
    # loadmodule /path/to/other_module.so

    ################################## NETWORK #####################################

    # By default, if no "bind" configuration directive is specified, Redis listens
    # for connections from all the network interfaces available on the server.
    # It is possible to listen to just one or multiple selected interfaces using
    # the "bind" configuration directive, followed by one or more IP addresses.
    #
    # Examples:
    #
    # bind 192.168.1.100 10.0.0.1
    # bind 127.0.0.1 ::1
    #
    # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
    # internet, binding to all the interfaces is dangerous and will expose the
    # instance to everybody on the internet. So by default we uncomment the
    # following bind directive, that will force Redis to listen only into
    # the IPv4 loopback interface address (this means Redis will be able to
    # accept connections only from clients running into the same computer it
    # is running).
    #
    # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
    # JUST COMMENT THE FOLLOWING LINE.
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    bind 127.0.0.1

    # Protected mode is a layer of security protection, in order to avoid that
    # Redis instances left open on the internet are accessed and exploited.
    #
    # When protected mode is on and if:
    #
    # 1) The server is not binding explicitly to a set of addresses using the
    #    "bind" directive.
    # 2) No password is configured.
    #
    # The server only accepts connections from clients connecting from the
    # IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
    # sockets.
    #
    # By default protected mode is enabled. You should disable it only if
    # you are sure you want clients from other hosts to connect to Redis
    # even if no authentication is configured, nor a specific set of interfaces
    # are explicitly listed using the "bind" directive.
    protected-mode yes

    # Accept connections on the specified port, default is 6379 (IANA #815344).
    # If port 0 is specified Redis will not listen on a TCP socket.
    port 6379

    # TCP listen() backlog.
    #
    # In high requests-per-second environments you need an high backlog in order
    # to avoid slow clients connections issues. Note that the Linux kernel
    # will silently truncate it to the value of /proc/sys/net/core/somaxconn so
    # make sure to raise both the value of somaxconn and tcp_max_syn_backlog
    # in order to get the desired effect.
    tcp-backlog 511

    # Unix socket.
    #
    # Specify the path for the Unix socket that will be used to listen for
    # incoming connections. There is no default, so Redis will not listen
    # on a unix socket when not specified.
    #
    # unixsocket /tmp/redis.sock
    # unixsocketperm 700

    # Close the connection after a client is idle for N seconds (0 to disable)
    timeout 0

    # TCP keepalive.
    #
    # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
    # of communication. This is useful for two reasons:
    #
    # 1) Detect dead peers.
    # 2) Take the connection alive from the point of view of network
    #    equipment in the middle.
    #
    # On Linux, the specified value (in seconds) is the period used to send ACKs.
    # Note that to close the connection the double of the time is needed.
    # On other kernels the period depends on the kernel configuration.
    #
    # A reasonable value for this option is 300 seconds, which is the new
    # Redis default starting with Redis 3.2.1.
    tcp-keepalive 300

    ################################# TLS/SSL #####################################

    # By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration
    # directive can be used to define TLS-listening ports. To enable TLS on the
    # default port, use:
    #
    # port 0
    # tls-port 6379

    # Configure a X.509 certificate and private key to use for authenticating the
    # server to connected clients, masters or cluster peers.  These files should be
    # PEM formatted.
    #
    # tls-cert-file redis.crt
    # tls-key-file redis.key

    # Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:
    #
    # tls-dh-params-file redis.dh

    # Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL
    # clients and peers.  Redis requires an explicit configuration of at least one
    # of these, and will not implicitly use the system wide configuration.
    #
    # tls-ca-cert-file ca.crt
    # tls-ca-cert-dir /etc/ssl/certs

    # By default, clients (including replica servers) on a TLS port are required
    # to authenticate using valid client side certificates.
    #
    # It is possible to disable authentication using this directive.
    #
    # tls-auth-clients no

    # By default, a Redis replica does not attempt to establish a TLS connection
    # with its master.
    #
    # Use the following directive to enable TLS on replication links.
    #
    # tls-replication yes

    # By default, the Redis Cluster bus uses a plain TCP connection. To enable
    # TLS for the bus protocol, use the following directive:
    #
    # tls-cluster yes

    # Explicitly specify TLS versions to support. Allowed values are case insensitive
    # and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL >= 1.1.1) or
    # any combination. To enable only TLSv1.2 and TLSv1.3, use:
    #
    # tls-protocols "TLSv1.2 TLSv1.3"

    # Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information
    # about the syntax of this string.
    #
    # Note: this configuration applies only to <= TLSv1.2.
    #
    # tls-ciphers DEFAULT:!MEDIUM

    # Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more
    # information about the syntax of this string, and specifically for TLSv1.3
    # ciphersuites.
    #
    # tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256

    # When choosing a cipher, use the server's preference instead of the client
    # preference. By default, the server follows the client's preference.
    #
    # tls-prefer-server-ciphers yes

    ################################# GENERAL #####################################

    # By default Redis does not run as a daemon. Use 'yes' if you need it.
    # Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
    daemonize no

    # If you run Redis from upstart or systemd, Redis can interact with your
    # supervision tree. Options:
    #   supervised no      - no supervision interaction
    #   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
    #   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
    #   supervised auto    - detect upstart or systemd method based on
    #                        UPSTART_JOB or NOTIFY_SOCKET environment variables
    # Note: these supervision methods only signal "process is ready."
    #       They do not enable continuous liveness pings back to your supervisor.
    supervised no

    # If a pid file is specified, Redis writes it where specified at startup
    # and removes it at exit.
    #
    # When the server runs non daemonized, no pid file is created if none is
    # specified in the configuration. When the server is daemonized, the pid file
    # is used even if not specified, defaulting to "/var/run/redis.pid".
    #
    # Creating a pid file is best effort: if Redis is not able to create it
    # nothing bad happens, the server will start and run normally.
    pidfile /opt/bitnami/redis/tmp/redis_6379.pid

    # Specify the server verbosity level.
    # This can be one of:
    # debug (a lot of information, useful for development/testing)
    # verbose (many rarely useful info, but not a mess like the debug level)
    # notice (moderately verbose, what you want in production probably)
    # warning (only very important / critical messages are logged)
    loglevel notice

    # Specify the log file name. Also the empty string can be used to force
    # Redis to log on the standard output. Note that if you use standard
    # output for logging but daemonize, logs will be sent to /dev/null
    logfile ""

    # To enable logging to the system logger, just set 'syslog-enabled' to yes,
    # and optionally update the other syslog parameters to suit your needs.
    # syslog-enabled no

    # Specify the syslog identity.
    # syslog-ident redis

    # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
    # syslog-facility local0

    # Set the number of databases. The default database is DB 0, you can select
    # a different one on a per-connection basis using SELECT <dbid> where
    # dbid is a number between 0 and 'databases'-1
    databases 16

    # By default Redis shows an ASCII art logo only when started to log to the
    # standard output and if the standard output is a TTY. Basically this means
    # that normally a logo is displayed only in interactive sessions.
    #
    # However it is possible to force the pre-4.0 behavior and always show a
    # ASCII art logo in startup logs by setting the following option to yes.
    always-show-logo yes

    ################################ SNAPSHOTTING  ################################
    #
    # Save the DB on disk:
    #
    #   save <seconds> <changes>
    #
    #   Will save the DB if both the given number of seconds and the given
    #   number of write operations against the DB occurred.
    #
    #   In the example below the behaviour will be to save:
    #   after 900 sec (15 min) if at least 1 key changed
    #   after 300 sec (5 min) if at least 10 keys changed
    #   after 60 sec if at least 10000 keys changed
    #
    #   Note: you can disable saving completely by commenting out all "save" lines.
    #
    #   It is also possible to remove all the previously configured save
    #   points by adding a save directive with a single empty string argument
    #   like in the following example:
    #
    #   save ""

    save 900 1
    save 300 10
    save 60 10000

    # By default Redis will stop accepting writes if RDB snapshots are enabled
    # (at least one save point) and the latest background save failed.
    # This will make the user aware (in a hard way) that data is not persisting
    # on disk properly, otherwise chances are that no one will notice and some
    # disaster will happen.
    #
    # If the background saving process will start working again Redis will
    # automatically allow writes again.
    #
    # However if you have setup your proper monitoring of the Redis server
    # and persistence, you may want to disable this feature so that Redis will
    # continue to work as usual even if there are problems with disk,
    # permissions, and so forth.
    stop-writes-on-bgsave-error yes

    # Compress string objects using LZF when dump .rdb databases?
    # For default that's set to 'yes' as it's almost always a win.
    # If you want to save some CPU in the saving child set it to 'no' but
    # the dataset will likely be bigger if you have compressible values or keys.
    rdbcompression yes

    # Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
    # This makes the format more resistant to corruption but there is a performance
    # hit to pay (around 10%) when saving and loading RDB files, so you can disable it
    # for maximum performances.
    #
    # RDB files created with checksum disabled have a checksum of zero that will
    # tell the loading code to skip the check.
    rdbchecksum yes

    # The filename where to dump the DB
    dbfilename dump.rdb

    # Remove RDB files used by replication in instances without persistence
    # enabled. By default this option is disabled, however there are environments
    # where for regulations or other security concerns, RDB files persisted on
    # disk by masters in order to feed replicas, or stored on disk by replicas
    # in order to load them for the initial synchronization, should be deleted
    # ASAP. Note that this option ONLY WORKS in instances that have both AOF
    # and RDB persistence disabled, otherwise is completely ignored.
    #
    # An alternative (and sometimes better) way to obtain the same effect is
    # to use diskless replication on both master and replicas instances. However
    # in the case of replicas, diskless is not always an option.
    rdb-del-sync-files no

    # The working directory.
    #
    # The DB will be written inside this directory, with the filename specified
    # above using the 'dbfilename' configuration directive.
    #
    # The Append Only File will also be created inside this directory.
    #
    # Note that you must specify a directory here, not a file name.
    dir /bitnami/redis/data

    ################################# REPLICATION #################################

    # Master-Replica replication. Use replicaof to make a Redis instance a copy of
    # another Redis server. A few things to understand ASAP about Redis replication.
    #
    #   +------------------+      +---------------+
    #   |      Master      | ---> |    Replica    |
    #   | (receive writes) |      |  (exact copy) |
    #   +------------------+      +---------------+
    #
    # 1) Redis replication is asynchronous, but you can configure a master to
    #    stop accepting writes if it appears to be not connected with at least
    #    a given number of replicas.
    # 2) Redis replicas are able to perform a partial resynchronization with the
    #    master if the replication link is lost for a relatively small amount of
    #    time. You may want to configure the replication backlog size (see the next
    #    sections of this file) with a sensible value depending on your needs.
    # 3) Replication is automatic and does not need user intervention. After a
    #    network partition replicas automatically try to reconnect to masters
    #    and resynchronize with them.
    #
    # replicaof <masterip> <masterport>

    # If the master is password protected (using the "requirepass" configuration
    # directive below) it is possible to tell the replica to authenticate before
    # starting the replication synchronization process, otherwise the master will
    # refuse the replica request.
    #
    # masterauth <master-password>
    #
    # However this is not enough if you are using Redis ACLs (for Redis version
    # 6 or greater), and the default user is not capable of running the PSYNC
    # command and/or other commands needed for replication. In this case it's
    # better to configure a special user to use with replication, and specify the
    # masteruser configuration as such:
    #
    # masteruser <username>
    #
    # When masteruser is specified, the replica will authenticate against its
    # master using the new AUTH form: AUTH <username> <password>.

    # When a replica loses its connection with the master, or when the replication
    # is still in progress, the replica can act in two different ways:
    #
    # 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
    #    still reply to client requests, possibly with out of date data, or the
    #    data set may just be empty if this is the first synchronization.
    #
    # 2) if replica-serve-stale-data is set to 'no' the replica will reply with
    #    an error "SYNC with master in progress" to all the kind of commands
    #    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
    #    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
    #    COMMAND, POST, HOST: and LATENCY.
    #
    replica-serve-stale-data yes

    # You can configure a replica instance to accept writes or not. Writing against
    # a replica instance may be useful to store some ephemeral data (because data
    # written on a replica will be easily deleted after resync with the master) but
    # may also cause problems if clients are writing to it because of a
    # misconfiguration.
    #
    # Since Redis 2.6 by default replicas are read-only.
    #
    # Note: read only replicas are not designed to be exposed to untrusted clients
    # on the internet. It's just a protection layer against misuse of the instance.
    # Still a read only replica exports by default all the administrative commands
    # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
    # security of read only replicas using 'rename-command' to shadow all the
    # administrative / dangerous commands.
    replica-read-only yes

    # Replication SYNC strategy: disk or socket.
    #
    # New replicas and reconnecting replicas that are not able to continue the
    # replication process just receiving differences, need to do what is called a
    # "full synchronization". An RDB file is transmitted from the master to the
    # replicas.
    #
    # The transmission can happen in two different ways:
    #
    # 1) Disk-backed: The Redis master creates a new process that writes the RDB
    #                 file on disk. Later the file is transferred by the parent
    #                 process to the replicas incrementally.
    # 2) Diskless: The Redis master creates a new process that directly writes the
    #              RDB file to replica sockets, without touching the disk at all.
    #
    # With disk-backed replication, while the RDB file is generated, more replicas
    # can be queued and served with the RDB file as soon as the current child
    # producing the RDB file finishes its work. With diskless replication instead
    # once the transfer starts, new replicas arriving will be queued and a new
    # transfer will start when the current one terminates.
    #
    # When diskless replication is used, the master waits a configurable amount of
    # time (in seconds) before starting the transfer in the hope that multiple
    # replicas will arrive and the transfer can be parallelized.
    #
    # With slow disks and fast (large bandwidth) networks, diskless replication
    # works better.
    repl-diskless-sync no

    # When diskless replication is enabled, it is possible to configure the delay
    # the server waits in order to spawn the child that transfers the RDB via socket
    # to the replicas.
    #
    # This is important since once the transfer starts, it is not possible to serve
    # new replicas arriving, that will be queued for the next RDB transfer, so the
    # server waits a delay in order to let more replicas arrive.
    #
    # The delay is specified in seconds, and by default is 5 seconds. To disable
    # it entirely just set it to 0 seconds and the transfer will start ASAP.
    repl-diskless-sync-delay 5

    # -----------------------------------------------------------------------------
    # WARNING: RDB diskless load is experimental. Since in this setup the replica
    # does not immediately store an RDB on disk, it may cause data loss during
    # failovers. RDB diskless load + Redis modules not handling I/O reads may also
    # cause Redis to abort in case of I/O errors during the initial synchronization
    # stage with the master. Use only if your do what you are doing.
    # -----------------------------------------------------------------------------
    #
    # Replica can load the RDB it reads from the replication link directly from the
    # socket, or store the RDB to a file and read that file after it was completely
    # received from the master.
    #
    # In many cases the disk is slower than the network, and storing and loading
    # the RDB file may increase replication time (and even increase the master's
    # Copy on Write memory and salve buffers).
    # However, parsing the RDB file directly from the socket may mean that we have
    # to flush the contents of the current database before the full rdb was
    # received. For this reason we have the following options:
    #
    # "disabled"    - Don't use diskless load (store the rdb file to the disk first)
    # "on-empty-db" - Use diskless load only when it is completely safe.
    # "swapdb"      - Keep a copy of the current db contents in RAM while parsing
    #                 the data directly from the socket. note that this requires
    #                 sufficient memory, if you don't have it, you risk an OOM kill.
    repl-diskless-load disabled

    # Replicas send PINGs to server in a predefined interval. It's possible to
    # change this interval with the repl_ping_replica_period option. The default
    # value is 10 seconds.
    #
    # repl-ping-replica-period 10

    # The following option sets the replication timeout for:
    #
    # 1) Bulk transfer I/O during SYNC, from the point of view of replica.
    # 2) Master timeout from the point of view of replicas (data, pings).
    # 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
    #
    # It is important to make sure that this value is greater than the value
    # specified for repl-ping-replica-period otherwise a timeout will be detected
    # every time there is low traffic between the master and the replica.
    #
    # repl-timeout 60

    # Disable TCP_NODELAY on the replica socket after SYNC?
    #
    # If you select "yes" Redis will use a smaller number of TCP packets and
    # less bandwidth to send data to replicas. But this can add a delay for
    # the data to appear on the replica side, up to 40 milliseconds with
    # Linux kernels using a default configuration.
    #
    # If you select "no" the delay for data to appear on the replica side will
    # be reduced but more bandwidth will be used for replication.
    #
    # By default we optimize for low latency, but in very high traffic conditions
    # or when the master and replicas are many hops away, turning this to "yes" may
    # be a good idea.
    repl-disable-tcp-nodelay no

    # Set the replication backlog size. The backlog is a buffer that accumulates
    # replica data when replicas are disconnected for some time, so that when a
    # replica wants to reconnect again, often a full resync is not needed, but a
    # partial resync is enough, just passing the portion of data the replica
    # missed while disconnected.
    #
    # The bigger the replication backlog, the longer the time the replica can be
    # disconnected and later be able to perform a partial resynchronization.
    #
    # The backlog is only allocated once there is at least a replica connected.
    #
    # repl-backlog-size 1mb

    # After a master has no longer connected replicas for some time, the backlog
    # will be freed. The following option configures the amount of seconds that
    # need to elapse, starting from the time the last replica disconnected, for
    # the backlog buffer to be freed.
    #
    # Note that replicas never free the backlog for timeout, since they may be
    # promoted to masters later, and should be able to correctly "partially
    # resynchronize" with the replicas: hence they should always accumulate backlog.
    #
    # A value of 0 means to never release the backlog.
    #
    # repl-backlog-ttl 3600

    # The replica priority is an integer number published by Redis in the INFO
    # output. It is used by Redis Sentinel in order to select a replica to promote
    # into a master if the master is no longer working correctly.
    #
    # A replica with a low priority number is considered better for promotion, so
    # for instance if there are three replicas with priority 10, 100, 25 Sentinel
    # will pick the one with priority 10, that is the lowest.
    #
    # However a special priority of 0 marks the replica as not able to perform the
    # role of master, so a replica with priority of 0 will never be selected by
    # Redis Sentinel for promotion.
    #
    # By default the priority is 100.
    replica-priority 100

    # It is possible for a master to stop accepting writes if there are less than
    # N replicas connected, having a lag less or equal than M seconds.
    #
    # The N replicas need to be in "online" state.
    #
    # The lag in seconds, that must be <= the specified value, is calculated from
    # the last ping received from the replica, that is usually sent every second.
    #
    # This option does not GUARANTEE that N replicas will accept the write, but
    # will limit the window of exposure for lost writes in case not enough replicas
    # are available, to the specified number of seconds.
    #
    # For example to require at least 3 replicas with a lag <= 10 seconds use:
    #
    # min-replicas-to-write 3
    # min-replicas-max-lag 10
    #
    # Setting one or the other to 0 disables the feature.
    #
    # By default min-replicas-to-write is set to 0 (feature disabled) and
    # min-replicas-max-lag is set to 10.

    # A Redis master is able to list the address and port of the attached
    # replicas in different ways. For example the "INFO replication" section
    # offers this information, which is used, among other tools, by
    # Redis Sentinel in order to discover replica instances.
    # Another place where this info is available is in the output of the
    # "ROLE" command of a master.
    #
    # The listed IP and address normally reported by a replica is obtained
    # in the following way:
    #
    #   IP: The address is auto detected by checking the peer address
    #   of the socket used by the replica to connect with the master.
    #
    #   Port: The port is communicated by the replica during the replication
    #   handshake, and is normally the port that the replica is using to
    #   listen for connections.
    #
    # However when port forwarding or Network Address Translation (NAT) is
    # used, the replica may be actually reachable via different IP and port
    # pairs. The following two options can be used by a replica in order to
    # report to its master a specific set of IP and port, so that both INFO
    # and ROLE will report those values.
    #
    # There is no need to use both the options if you need to override just
    # the port or the IP address.
    #
    # replica-announce-ip 5.5.5.5
    # replica-announce-port 1234

    ############################### KEYS TRACKING #################################

    # Redis implements server assisted support for client side caching of values.
    # This is implemented using an invalidation table that remembers, using
    # 16 millions of slots, what clients may have certain subsets of keys. In turn
    # this is used in order to send invalidation messages to clients. Please
    # to understand more about the feature check this page:
    #
    #   https://redis.io/topics/client-side-caching
    #
    # When tracking is enabled for a client, all the read only queries are assumed
    # to be cached: this will force Redis to store information in the invalidation
    # table. When keys are modified, such information is flushed away, and
    # invalidation messages are sent to the clients. However if the workload is
    # heavily dominated by reads, Redis could use more and more memory in order
    # to track the keys fetched by many clients.
    #
    # For this reason it is possible to configure a maximum fill value for the
    # invalidation table. By default it is set to 1M of keys, and once this limit
    # is reached, Redis will start to evict keys in the invalidation table
    # even if they were not modified, just to reclaim memory: this will in turn
    # force the clients to invalidate the cached values. Basically the table
    # maximum size is a trade off between the memory you want to spend server
    # side to track information about who cached what, and the ability of clients
    # to retain cached objects in memory.
    #
    # If you set the value to 0, it means there are no limits, and Redis will
    # retain as many keys as needed in the invalidation table.
    # In the "stats" INFO section, you can find information about the number of
    # keys in the invalidation table at every given moment.
    #
    # Note: when key tracking is used in broadcasting mode, no memory is used
    # in the server side so this setting is useless.
    #
    # tracking-table-max-keys 1000000

    ################################## SECURITY ###################################

    # Warning: since Redis is pretty fast an outside user can try up to
    # 1 million passwords per second against a modern box. This means that you
    # should use very strong passwords, otherwise they will be very easy to break.
    # Note that because the password is really a shared secret between the client
    # and the server, and should not be memorized by any human, the password
    # can be easily a long string from /dev/urandom or whatever, so by using a
    # long and unguessable password no brute force attack will be possible.

    # Redis ACL users are defined in the following format:
    #
    #   user <username> ... acl rules ...
    #
    # For example:
    #
    #   user worker +@list +@connection ~jobs:* on >ffa9203c493aa99
    #
    # The special username "default" is used for new connections. If this user
    # has the "nopass" rule, then new connections will be immediately authenticated
    # as the "default" user without the need of any password provided via the
    # AUTH command. Otherwise if the "default" user is not flagged with "nopass"
    # the connections will start in not authenticated state, and will require
    # AUTH (or the HELLO command AUTH option) in order to be authenticated and
    # start to work.
    #
    # The ACL rules that describe what an user can do are the following:
    #
    #  on           Enable the user: it is possible to authenticate as this user.
    #  off          Disable the user: it's no longer possible to authenticate
    #               with this user, however the already authenticated connections
    #               will still work.
    #  +<command>   Allow the execution of that command
    #  -<command>   Disallow the execution of that command
    #  +@<category> Allow the execution of all the commands in such category
    #               with valid categories are like @admin, @set, @sortedset, ...
    #               and so forth, see the full list in the server.c file where
    #               the Redis command table is described and defined.
    #               The special category @all means all the commands, but currently
    #               present in the server, and that will be loaded in the future
    #               via modules.
    #  +<command>|subcommand    Allow a specific subcommand of an otherwise
    #                           disabled command. Note that this form is not
    #                           allowed as negative like -DEBUG|SEGFAULT, but
    #                           only additive starting with "+".
    #  allcommands  Alias for +@all. Note that it implies the ability to execute
    #               all the future commands loaded via the modules system.
    #  nocommands   Alias for -@all.
    #  ~<pattern>   Add a pattern of keys that can be mentioned as part of
    #               commands. For instance ~* allows all the keys. The pattern
    #               is a glob-style pattern like the one of KEYS.
    #               It is possible to specify multiple patterns.
    #  allkeys      Alias for ~*
    #  resetkeys    Flush the list of allowed keys patterns.
    #  ><password>  Add this password to the list of valid password for the user.
    #               For example >mypass will add "mypass" to the list.
    #               This directive clears the "nopass" flag (see later).
    #  <<password>  Remove this password from the list of valid passwords.
    #  nopass       All the set passwords of the user are removed, and the user
    #               is flagged as requiring no password: it means that every
    #               password will work against this user. If this directive is
    #               used for the default user, every new connection will be
    #               immediately authenticated with the default user without
    #               any explicit AUTH command required. Note that the "resetpass"
    #               directive will clear this condition.
    #  resetpass    Flush the list of allowed passwords. Moreover removes the
    #               "nopass" status. After "resetpass" the user has no associated
    #               passwords and there is no way to authenticate without adding
    #               some password (or setting it as "nopass" later).
    #  reset        Performs the following actions: resetpass, resetkeys, off,
    #               -@all. The user returns to the same state it has immediately
    #               after its creation.
    #
    # ACL rules can be specified in any order: for instance you can start with
    # passwords, then flags, or key patterns. However note that the additive
    # and subtractive rules will CHANGE MEANING depending on the ordering.
    # For instance see the following example:
    #
    #   user alice on +@all -DEBUG ~* >somepassword
    #
    # This will allow "alice" to use all the commands with the exception of the
    # DEBUG command, since +@all added all the commands to the set of the commands
    # alice can use, and later DEBUG was removed. However if we invert the order
    # of two ACL rules the result will be different:
    #
    #   user alice on -DEBUG +@all ~* >somepassword
    #
    # Now DEBUG was removed when alice had yet no commands in the set of allowed
    # commands, later all the commands are added, so the user will be able to
    # execute everything.
    #
    # Basically ACL rules are processed left-to-right.
    #
    # For more information about ACL configuration please refer to
    # the Redis web site at https://redis.io/topics/acl

    # ACL LOG
    #
    # The ACL Log tracks failed commands and authentication events associated
    # with ACLs. The ACL Log is useful to troubleshoot failed commands blocked
    # by ACLs. The ACL Log is stored in and consumes memory. There is no limit
    # to its length.You can reclaim memory with ACL LOG RESET or set a maximum
    # length below.
    acllog-max-len 128

    # Using an external ACL file
    #
    # Instead of configuring users here in this file, it is possible to use
    # a stand-alone file just listing users. The two methods cannot be mixed:
    # if you configure users here and at the same time you activate the exteranl
    # ACL file, the server will refuse to start.
    #
    # The format of the external ACL user file is exactly the same as the
    # format that is used inside redis.conf to describe users.
    #
    # aclfile /etc/redis/users.acl

    # IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatibility
    # layer on top of the new ACL system. The option effect will be just setting
    # the password for the default user. Clients will still authenticate using
    # AUTH <password> as usually, or more explicitly with AUTH default <password>
    # if they follow the new protocol: both will work.
    #
    # requirepass foobared

    # Command renaming (DEPRECATED).
    #
    # ------------------------------------------------------------------------
    # WARNING: avoid using this option if possible. Instead use ACLs to remove
    # commands from the default user, and put them only in some admin user you
    # create for administrative purposes.
    # ------------------------------------------------------------------------
    #
    # It is possible to change the name of dangerous commands in a shared
    # environment. For instance the CONFIG command may be renamed into something
    # hard to guess so that it will still be available for internal-use tools
    # but not available for general clients.
    #
    # Example:
    #
    # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
    #
    # It is also possible to completely kill a command by renaming it into
    # an empty string:
    #
    # rename-command CONFIG ""
    #
    # Please note that changing the name of commands that are logged into the
    # AOF file or transmitted to replicas may cause problems.

    ################################### CLIENTS ####################################

    # Set the max number of connected clients at the same time. By default
    # this limit is set to 10000 clients, however if the Redis server is not
    # able to configure the process file limit to allow for the specified limit
    # the max number of allowed clients is set to the current file limit
    # minus 32 (as Redis reserves a few file descriptors for internal uses).
    #
    # Once the limit is reached Redis will close all the new connections sending
    # an error 'max number of clients reached'.
    #
    # maxclients 10000

    ############################## MEMORY MANAGEMENT ################################

    # Set a memory usage limit to the specified amount of bytes.
    # When the memory limit is reached Redis will try to remove keys
    # according to the eviction policy selected (see maxmemory-policy).
    #
    # If Redis can't remove keys according to the policy, or if the policy is
    # set to 'noeviction', Redis will start to reply with errors to commands
    # that would use more memory, like SET, LPUSH, and so on, and will continue
    # to reply to read-only commands like GET.
    #
    # This option is usually useful when using Redis as an LRU or LFU cache, or to
    # set a hard memory limit for an instance (using the 'noeviction' policy).
    #
    # WARNING: If you have replicas attached to an instance with maxmemory on,
    # the size of the output buffers needed to feed the replicas are subtracted
    # from the used memory count, so that network problems / resyncs will
    # not trigger a loop where keys are evicted, and in turn the output
    # buffer of replicas is full with DELs of keys evicted triggering the deletion
    # of more keys, and so forth until the database is completely emptied.
    #
    # In short... if you have replicas attached it is suggested that you set a lower
    # limit for maxmemory so that there is some free RAM on the system for replica
    # output buffers (but this is not needed if the policy is 'noeviction').
    #
    # maxmemory <bytes>

    # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
    # is reached. You can select one from the following behaviors:
    #
    # volatile-lru -> Evict using approximated LRU, only keys with an expire set.
    # allkeys-lru -> Evict any key using approximated LRU.
    # volatile-lfu -> Evict using approximated LFU, only keys with an expire set.
    # allkeys-lfu -> Evict any key using approximated LFU.
    # volatile-random -> Remove a random key having an expire set.
    # allkeys-random -> Remove a random key, any key.
    # volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
    # noeviction -> Don't evict anything, just return an error on write operations.
    #
    # LRU means Least Recently Used
    # LFU means Least Frequently Used
    #
    # Both LRU, LFU and volatile-ttl are implemented using approximated
    # randomized algorithms.
    #
    # Note: with any of the above policies, Redis will return an error on write
    #       operations, when there are no suitable keys for eviction.
    #
    #       At the date of writing these commands are: set setnx setex append
    #       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
    #       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
    #       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
    #       getset mset msetnx exec sort
    #
    # The default is:
    #
    # maxmemory-policy noeviction

    # LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
    # algorithms (in order to save memory), so you can tune it for speed or
    # accuracy. For default Redis will check five keys and pick the one that was
    # used less recently, you can change the sample size using the following
    # configuration directive.
    #
    # The default of 5 produces good enough results. 10 Approximates very closely
    # true LRU but costs more CPU. 3 is faster but not very accurate.
    #
    # maxmemory-samples 5

    # Starting from Redis 5, by default a replica will ignore its maxmemory setting
    # (unless it is promoted to master after a failover or manually). It means
    # that the eviction of keys will be just handled by the master, sending the
    # DEL commands to the replica as keys evict in the master side.
    #
    # This behavior ensures that masters and replicas stay consistent, and is usually
    # what you want, however if your replica is writable, or you want the replica
    # to have a different memory setting, and you are sure all the writes performed
    # to the replica are idempotent, then you may change this default (but be sure
    # to understand what you are doing).
    #
    # Note that since the replica by default does not evict, it may end using more
    # memory than the one set via maxmemory (there are certain buffers that may
    # be larger on the replica, or data structures may sometimes take more memory
    # and so forth). So make sure you monitor your replicas and make sure they
    # have enough memory to never hit a real out-of-memory condition before the
    # master hits the configured maxmemory setting.
    #
    # replica-ignore-maxmemory yes

    # Redis reclaims expired keys in two ways: upon access when those keys are
    # found to be expired, and also in background, in what is called the
    # "active expire key". The key space is slowly and interactively scanned
    # looking for expired keys to reclaim, so that it is possible to free memory
    # of keys that are expired and will never be accessed again in a short time.
    #
    # The default effort of the expire cycle will try to avoid having more than
    # ten percent of expired keys still in memory, and will try to avoid consuming
    # more than 25% of total memory and to add latency to the system. However
    # it is possible to increase the expire "effort" that is normally set to
    # "1", to a greater value, up to the value "10". At its maximum value the
    # system will use more CPU, longer cycles (and technically may introduce
    # more latency), and will tollerate less already expired keys still present
    # in the system. It's a tradeoff between memory, CPU and latecy.
    #
    # active-expire-effort 1

    ############################# LAZY FREEING ####################################

    # Redis has two primitives to delete keys. One is called DEL and is a blocking
    # deletion of the object. It means that the server stops processing new commands
    # in order to reclaim all the memory associated with an object in a synchronous
    # way. If the key deleted is associated with a small object, the time needed
    # in order to execute the DEL command is very small and comparable to most other
    # O(1) or O(log_N) commands in Redis. However if the key is associated with an
    # aggregated value containing millions of elements, the server can block for
    # a long time (even seconds) in order to complete the operation.
    #
    # For the above reasons Redis also offers non blocking deletion primitives
    # such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
    # FLUSHDB commands, in order to reclaim memory in background. Those commands
    # are executed in constant time. Another thread will incrementally free the
    # object in the background as fast as possible.
    #
    # DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
    # It's up to the design of the application to understand when it is a good
    # idea to use one or the other. However the Redis server sometimes has to
    # delete keys or flush the whole database as a side effect of other operations.
    # Specifically Redis deletes objects independently of a user call in the
    # following scenarios:
    #
    # 1) On eviction, because of the maxmemory and maxmemory policy configurations,
    #    in order to make room for new data, without going over the specified
    #    memory limit.
    # 2) Because of expire: when a key with an associated time to live (see the
    #    EXPIRE command) must be deleted from memory.
    # 3) Because of a side effect of a command that stores data on a key that may
    #    already exist. For example the RENAME command may delete the old key
    #    content when it is replaced with another one. Similarly SUNIONSTORE
    #    or SORT with STORE option may delete existing keys. The SET command
    #    itself removes any old content of the specified key in order to replace
    #    it with the specified string.
    # 4) During replication, when a replica performs a full resynchronization with
    #    its master, the content of the whole database is removed in order to
    #    load the RDB file just transferred.
    #
    # In all the above cases the default is to delete objects in a blocking way,
    # like if DEL was called. However you can configure each case specifically
    # in order to instead release memory in a non-blocking way like if UNLINK
    # was called, using the following configuration directives.

    lazyfree-lazy-eviction no
    lazyfree-lazy-expire no
    lazyfree-lazy-server-del no
    replica-lazy-flush no

    # It is also possible, for the case when to replace the user code DEL calls
    # with UNLINK calls is not easy, to modify the default behavior of the DEL
    # command to act exactly like UNLINK, using the following configuration
    # directive:

    lazyfree-lazy-user-del no

    ################################ THREADED I/O #################################

    # Redis is mostly single threaded, however there are certain threaded
    # operations such as UNLINK, slow I/O accesses and other things that are
    # performed on side threads.
    #
    # Now it is also possible to handle Redis clients socket reads and writes
    # in different I/O threads. Since especially writing is so slow, normally
    # Redis users use pipelining in order to speedup the Redis performances per
    # core, and spawn multiple instances in order to scale more. Using I/O
    # threads it is possible to easily speedup two times Redis without resorting
    # to pipelining nor sharding of the instance.
    #
    # By default threading is disabled, we suggest enabling it only in machines
    # that have at least 4 or more cores, leaving at least one spare core.
    # Using more than 8 threads is unlikely to help much. We also recommend using
    # threaded I/O only if you actually have performance problems, with Redis
    # instances being able to use a quite big percentage of CPU time, otherwise
    # there is no point in using this feature.
    #
    # So for instance if you have a four cores boxes, try to use 2 or 3 I/O
    # threads, if you have a 8 cores, try to use 6 threads. In order to
    # enable I/O threads use the following configuration directive:
    #
    # io-threads 4
    #
    # Setting io-threads to 1 will just use the main thread as usually.
    # When I/O threads are enabled, we only use threads for writes, that is
    # to thread the write(2) syscall and transfer the client buffers to the
    # socket. However it is also possible to enable threading of reads and
    # protocol parsing using the following configuration directive, by setting
    # it to yes:
    #
    # io-threads-do-reads no
    #
    # Usually threading reads doesn't help much.
    #
    # NOTE 1: This configuration directive cannot be changed at runtime via
    # CONFIG SET. Aso this feature currently does not work when SSL is
    # enabled.
    #
    # NOTE 2: If you want to test the Redis speedup using redis-benchmark, make
    # sure you also run the benchmark itself in threaded mode, using the
    # --threads option to match the number of Redis theads, otherwise you'll not
    # be able to notice the improvements.

    ############################## APPEND ONLY MODE ###############################

    # By default Redis asynchronously dumps the dataset on disk. This mode is
    # good enough in many applications, but an issue with the Redis process or
    # a power outage may result into a few minutes of writes lost (depending on
    # the configured save points).
    #
    # The Append Only File is an alternative persistence mode that provides
    # much better durability. For instance using the default data fsync policy
    # (see later in the config file) Redis can lose just one second of writes in a
    # dramatic event like a server power outage, or a single write if something
    # wrong with the Redis process itself happens, but the operating system is
    # still running correctly.
    #
    # AOF and RDB persistence can be enabled at the same time without problems.
    # If the AOF is enabled on startup Redis will load the AOF, that is the file
    # with the better durability guarantees.
    #
    # Please check http://redis.io/topics/persistence for more information.

    appendonly no

    # The name of the append only file (default: "appendonly.aof")

    appendfilename "appendonly.aof"

    # The fsync() call tells the Operating System to actually write data on disk
    # instead of waiting for more data in the output buffer. Some OS will really flush
    # data on disk, some other OS will just try to do it ASAP.
    #
    # Redis supports three different modes:
    #
    # no: don't fsync, just let the OS flush the data when it wants. Faster.
    # always: fsync after every write to the append only log. Slow, Safest.
    # everysec: fsync only one time every second. Compromise.
    #
    # The default is "everysec", as that's usually the right compromise between
    # speed and data safety. It's up to you to understand if you can relax this to
    # "no" that will let the operating system flush the output buffer when
    # it wants, for better performances (but if you can live with the idea of
    # some data loss consider the default persistence mode that's snapshotting),
    # or on the contrary, use "always" that's very slow but a bit safer than
    # everysec.
    #
    # More details please check the following article:
    # http://antirez.com/post/redis-persistence-demystified.html
    #
    # If unsure, use "everysec".

    # appendfsync always
    appendfsync everysec
    # appendfsync no

    # When the AOF fsync policy is set to always or everysec, and a background
    # saving process (a background save or AOF log background rewriting) is
    # performing a lot of I/O against the disk, in some Linux configurations
    # Redis may block too long on the fsync() call. Note that there is no fix for
    # this currently, as even performing fsync in a different thread will block
    # our synchronous write(2) call.
    #
    # In order to mitigate this problem it's possible to use the following option
    # that will prevent fsync() from being called in the main process while a
    # BGSAVE or BGREWRITEAOF is in progress.
    #
    # This means that while another child is saving, the durability of Redis is
    # the same as "appendfsync none". In practical terms, this means that it is
    # possible to lose up to 30 seconds of log in the worst scenario (with the
    # default Linux settings).
    #
    # If you have latency problems turn this to "yes". Otherwise leave it as
    # "no" that is the safest pick from the point of view of durability.

    no-appendfsync-on-rewrite no

    # Automatic rewrite of the append only file.
    # Redis is able to automatically rewrite the log file implicitly calling
    # BGREWRITEAOF when the AOF log size grows by the specified percentage.
    #
    # This is how it works: Redis remembers the size of the AOF file after the
    # latest rewrite (if no rewrite has happened since the restart, the size of
    # the AOF at startup is used).
    #
    # This base size is compared to the current size. If the current size is
    # bigger than the specified percentage, the rewrite is triggered. Also
    # you need to specify a minimal size for the AOF file to be rewritten, this
    # is useful to avoid rewriting the AOF file even if the percentage increase
    # is reached but it is still pretty small.
    #
    # Specify a percentage of zero in order to disable the automatic AOF
    # rewrite feature.

    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb

    # An AOF file may be found to be truncated at the end during the Redis
    # startup process, when the AOF data gets loaded back into memory.
    # This may happen when the system where Redis is running
    # crashes, especially when an ext4 filesystem is mounted without the
    # data=ordered option (however this can't happen when Redis itself
    # crashes or aborts but the operating system still works correctly).
    #
    # Redis can either exit with an error when this happens, or load as much
    # data as possible (the default now) and start if the AOF file is found
    # to be truncated at the end. The following option controls this behavior.
    #
    # If aof-load-truncated is set to yes, a truncated AOF file is loaded and
    # the Redis server starts emitting a log to inform the user of the event.
    # Otherwise if the option is set to no, the server aborts with an error
    # and refuses to start. When the option is set to no, the user requires
    # to fix the AOF file using the "redis-check-aof" utility before to restart
    # the server.
    #
    # Note that if the AOF file will be found to be corrupted in the middle
    # the server will still exit with an error. This option only applies when
    # Redis will try to read more data from the AOF file but not enough bytes
    # will be found.
    aof-load-truncated yes

    # When rewriting the AOF file, Redis is able to use an RDB preamble in the
    # AOF file for faster rewrites and recoveries. When this option is turned
    # on the rewritten AOF file is composed of two different stanzas:
    #
    #   [RDB file][AOF tail]
    #
    # When loading Redis recognizes that the AOF file starts with the "REDIS"
    # string and loads the prefixed RDB file, and continues loading the AOF
    # tail.
    aof-use-rdb-preamble yes

    ################################ LUA SCRIPTING  ###############################

    # Max execution time of a Lua script in milliseconds.
    #
    # If the maximum execution time is reached Redis will log that a script is
    # still in execution after the maximum allowed time and will start to
    # reply to queries with an error.
    #
    # When a long running script exceeds the maximum execution time only the
    # SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
    # used to stop a script that did not yet called write commands. The second
    # is the only way to shut down the server in the case a write command was
    # already issued by the script but the user doesn't want to wait for the natural
    # termination of the script.
    #
    # Set it to 0 or a negative value for unlimited execution without warnings.
    lua-time-limit 5000

    ################################ REDIS CLUSTER  ###############################

    # Normal Redis instances can't be part of a Redis Cluster; only nodes that are
    # started as cluster nodes can. In order to start a Redis instance as a
    # cluster node enable the cluster support uncommenting the following:
    #
    cluster-enabled yes

    # Every cluster node has a cluster configuration file. This file is not
    # intended to be edited by hand. It is created and updated by Redis nodes.
    # Every Redis Cluster node requires a different cluster configuration file.
    # Make sure that instances running in the same system do not have
    # overlapping cluster configuration file names.
    #
    cluster-config-file /bitnami/redis/data/nodes.conf

    # Cluster node timeout is the amount of milliseconds a node must be unreachable
    # for it to be considered in failure state.
    # Most other internal time limits are multiple of the node timeout.
    #
    # cluster-node-timeout 15000

    # A replica of a failing master will avoid to start a failover if its data
    # looks too old.
    #
    # There is no simple way for a replica to actually have an exact measure of
    # its "data age", so the following two checks are performed:
    #
    # 1) If there are multiple replicas able to failover, they exchange messages
    #    in order to try to give an advantage to the replica with the best
    #    replication offset (more data from the master processed).
    #    Replicas will try to get their rank by offset, and apply to the start
    #    of the failover a delay proportional to their rank.
    #
    # 2) Every single replica computes the time of the last interaction with
    #    its master. This can be the last ping or command received (if the master
    #    is still in the "connected" state), or the time that elapsed since the
    #    disconnection with the master (if the replication link is currently down).
    #    If the last interaction is too old, the replica will not try to failover
    #    at all.
    #
    # The point "2" can be tuned by user. Specifically a replica will not perform
    # the failover if, since the last interaction with the master, the time
    # elapsed is greater than:
    #
    #   (node-timeout * replica-validity-factor) + repl-ping-replica-period
    #
    # So for example if node-timeout is 30 seconds, and the replica-validity-factor
    # is 10, and assuming a default repl-ping-replica-period of 10 seconds, the
    # replica will not try to failover if it was not able to talk with the master
    # for longer than 310 seconds.
    #
    # A large replica-validity-factor may allow replicas with too old data to failover
    # a master, while a too small value may prevent the cluster from being able to
    # elect a replica at all.
    #
    # For maximum availability, it is possible to set the replica-validity-factor
    # to a value of 0, which means, that replicas will always try to failover the
    # master regardless of the last time they interacted with the master.
    # (However they'll always try to apply a delay proportional to their
    # offset rank).
    #
    # Zero is the only value able to guarantee that when all the partitions heal
    # the cluster will always be able to continue.
    #
    # cluster-replica-validity-factor 10

    # Cluster replicas are able to migrate to orphaned masters, that are masters
    # that are left without working replicas. This improves the cluster ability
    # to resist to failures as otherwise an orphaned master can't be failed over
    # in case of failure if it has no working replicas.
    #
    # Replicas migrate to orphaned masters only if there are still at least a
    # given number of other working replicas for their old master. This number
    # is the "migration barrier". A migration barrier of 1 means that a replica
    # will migrate only if there is at least 1 other working replica for its master
    # and so forth. It usually reflects the number of replicas you want for every
    # master in your cluster.
    #
    # Default is 1 (replicas migrate only if their masters remain with at least
    # one replica). To disable migration just set it to a very large value.
    # A value of 0 can be set but is useful only for debugging and dangerous
    # in production.
    #
    # cluster-migration-barrier 1

    # By default Redis Cluster nodes stop accepting queries if they detect there
    # is at least an hash slot uncovered (no available node is serving it).
    # This way if the cluster is partially down (for example a range of hash slots
    # are no longer covered) all the cluster becomes, eventually, unavailable.
    # It automatically returns available as soon as all the slots are covered again.
    #
    # However sometimes you want the subset of the cluster which is working,
    # to continue to accept queries for the part of the key space that is still
    # covered. In order to do so, just set the cluster-require-full-coverage
    # option to no.
    #
    # cluster-require-full-coverage yes

    # This option, when set to yes, prevents replicas from trying to failover its
    # master during master failures. However the master can still perform a
    # manual failover, if forced to do so.
    #
    # This is useful in different scenarios, especially in the case of multiple
    # data center operations, where we want one side to never be promoted if not
    # in the case of a total DC failure.
    #
    # cluster-replica-no-failover no

    # This option, when set to yes, allows nodes to serve read traffic while the
    # the cluster is in a down state, as long as it believes it owns the slots.
    #
    # This is useful for two cases.  The first case is for when an application
    # doesn't require consistency of data during node failures or network partitions.
    # One example of this is a cache, where as long as the node has the data it
    # should be able to serve it.
    #
    # The second use case is for configurations that don't meet the recommended
    # three shards but want to enable cluster mode and scale later. A
    # master outage in a 1 or 2 shard configuration causes a read/write outage to the
    # entire cluster without this option set, with it set there is only a write outage.
    # Without a quorum of masters, slot ownership will not change automatically.
    #
    # cluster-allow-reads-when-down no

    # In order to setup your cluster make sure to read the documentation
    # available at http://redis.io web site.

    ########################## CLUSTER DOCKER/NAT support  ########################

    # In certain deployments, Redis Cluster nodes address discovery fails, because
    # addresses are NAT-ted or because ports are forwarded (the typical case is
    # Docker and other containers).
    #
    # In order to make Redis Cluster working in such environments, a static
    # configuration where each node knows its public address is needed. The
    # following two options are used for this scope, and are:
    #
    # * cluster-announce-ip
    # * cluster-announce-port
    # * cluster-announce-bus-port
    #
    # Each instruct the node about its address, client port, and cluster message
    # bus port. The information is then published in the header of the bus packets
    # so that other nodes will be able to correctly map the address of the node
    # publishing the information.
    #
    # If the above options are not used, the normal Redis Cluster auto-detection
    # will be used instead.
    #
    # Note that when remapped, the bus port may not be at the fixed offset of
    # clients port + 10000, so you can specify any port and bus-port depending
    # on how they get remapped. If the bus-port is not set, a fixed offset of
    # 10000 will be used as usually.
    #
    # Example:
    #
    # cluster-announce-ip 10.1.1.5
    # cluster-announce-port 6379
    # cluster-announce-bus-port 6380

    ################################## SLOW LOG ###################################

    # The Redis Slow Log is a system to log queries that exceeded a specified
    # execution time. The execution time does not include the I/O operations
    # like talking with the client, sending the reply and so forth,
    # but just the time needed to actually execute the command (this is the only
    # stage of command execution where the thread is blocked and can not serve
    # other requests in the meantime).
    #
    # You can configure the slow log with two parameters: one tells Redis
    # what is the execution time, in microseconds, to exceed in order for the
    # command to get logged, and the other parameter is the length of the
    # slow log. When a new command is logged the oldest one is removed from the
    # queue of logged commands.

    # The following time is expressed in microseconds, so 1000000 is equivalent
    # to one second. Note that a negative number disables the slow log, while
    # a value of zero forces the logging of every command.
    slowlog-log-slower-than 10000

    # There is no limit to this length. Just be aware that it will consume memory.
    # You can reclaim memory used by the slow log with SLOWLOG RESET.
    slowlog-max-len 128

    ################################ LATENCY MONITOR ##############################

    # The Redis latency monitoring subsystem samples different operations
    # at runtime in order to collect data related to possible sources of
    # latency of a Redis instance.
    #
    # Via the LATENCY command this information is available to the user that can
    # print graphs and obtain reports.
    #
    # The system only logs operations that were performed in a time equal or
    # greater than the amount of milliseconds specified via the
    # latency-monitor-threshold configuration directive. When its value is set
    # to zero, the latency monitor is turned off.
    #
    # By default latency monitoring is disabled since it is mostly not needed
    # if you don't have latency issues, and collecting data has a performance
    # impact, that while very small, can be measured under big load. Latency
    # monitoring can easily be enabled at runtime using the command
    # "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
    latency-monitor-threshold 0

    ############################# EVENT NOTIFICATION ##############################

    # Redis can notify Pub/Sub clients about events happening in the key space.
    # This feature is documented at http://redis.io/topics/notifications
    #
    # For instance if keyspace events notification is enabled, and a client
    # performs a DEL operation on key "foo" stored in the Database 0, two
    # messages will be published via Pub/Sub:
    #
    # PUBLISH __keyspace@0__:foo del
    # PUBLISH __keyevent@0__:del foo
    #
    # It is possible to select the events that Redis will notify among a set
    # of classes. Every class is identified by a single character:
    #
    #  K     Keyspace events, published with __keyspace@<db>__ prefix.
    #  E     Keyevent events, published with __keyevent@<db>__ prefix.
    #  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
    #  $     String commands
    #  l     List commands
    #  s     Set commands
    #  h     Hash commands
    #  z     Sorted set commands
    #  x     Expired events (events generated every time a key expires)
    #  e     Evicted events (events generated when a key is evicted for maxmemory)
    #  t     Stream commands
    #  m     Key-miss events (Note: It is not included in the 'A' class)
    #  A     Alias for g$lshzxet, so that the "AKE" string means all the events
    #        (Except key-miss events which are excluded from 'A' due to their
    #         unique nature).
    #
    #  The "notify-keyspace-events" takes as argument a string that is composed
    #  of zero or multiple characters. The empty string means that notifications
    #  are disabled.
    #
    #  Example: to enable list and generic events, from the point of view of the
    #           event name, use:
    #
    #  notify-keyspace-events Elg
    #
    #  Example 2: to get the stream of the expired keys subscribing to channel
    #             name __keyevent@0__:expired use:
    #
    #  notify-keyspace-events Ex
    #
    #  By default all notifications are disabled because most users don't need
    #  this feature and the feature has some overhead. Note that if you don't
    #  specify at least one of K or E, no events will be delivered.
    notify-keyspace-events ""

    ############################### GOPHER SERVER #################################

    # Redis contains an implementation of the Gopher protocol, as specified in
    # the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).
    #
    # The Gopher protocol was very popular in the late '90s. It is an alternative
    # to the web, and the implementation both server and client side is so simple
    # that the Redis server has just 100 lines of code in order to implement this
    # support.
    #
    # What do you do with Gopher nowadays? Well Gopher never *really* died, and
    # lately there is a movement in order for the Gopher more hierarchical content
    # composed of just plain text documents to be resurrected. Some want a simpler
    # internet, others believe that the mainstream internet became too much
    # controlled, and it's cool to create an alternative space for people that
    # want a bit of fresh air.
    #
    # Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol
    # as a gift.
    #
    # --- HOW IT WORKS? ---
    #
    # The Redis Gopher support uses the inline protocol of Redis, and specifically
    # two kind of inline requests that were anyway illegal: an empty request
    # or any request that starts with "/" (there are no Redis commands starting
    # with such a slash). Normal RESP2/RESP3 requests are completely out of the
    # path of the Gopher protocol implementation and are served as usually as well.
    #
    # If you open a connection to Redis when Gopher is enabled and send it
    # a string like "/foo", if there is a key named "/foo" it is served via the
    # Gopher protocol.
    #
    # In order to create a real Gopher "hole" (the name of a Gopher site in Gopher
    # talking), you likely need a script like the following:
    #
    #   https://github.com/antirez/gopher2redis
    #
    # --- SECURITY WARNING ---
    #
    # If you plan to put Redis on the internet in a publicly accessible address
    # to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.
    # Once a password is set:
    #
    #   1. The Gopher server (when enabled, not by default) will still serve
    #      content via Gopher.
    #   2. However other commands cannot be called before the client will
    #      authenticate.
    #
    # So use the 'requirepass' option to protect your instance.
    #
    # To enable Gopher support uncomment the following line and set
    # the option from no (the default) to yes.
    #
    # gopher-enabled no

    ############################### ADVANCED CONFIG ###############################

    # Hashes are encoded using a memory efficient data structure when they have a
    # small number of entries, and the biggest entry does not exceed a given
    # threshold. These thresholds can be configured using the following directives.
    hash-max-ziplist-entries 512
    hash-max-ziplist-value 64

    # Lists are also encoded in a special way to save a lot of space.
    # The number of entries allowed per internal list node can be specified
    # as a fixed maximum size or a maximum number of elements.
    # For a fixed maximum size, use -5 through -1, meaning:
    # -5: max size: 64 Kb  <-- not recommended for normal workloads
    # -4: max size: 32 Kb  <-- not recommended
    # -3: max size: 16 Kb  <-- probably not recommended
    # -2: max size: 8 Kb   <-- good
    # -1: max size: 4 Kb   <-- good
    # Positive numbers mean store up to _exactly_ that number of elements
    # per list node.
    # The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
    # but if your use case is unique, adjust the settings as necessary.
    list-max-ziplist-size -2

    # Lists may also be compressed.
    # Compress depth is the number of quicklist ziplist nodes from *each* side of
    # the list to *exclude* from compression.  The head and tail of the list
    # are always uncompressed for fast push/pop operations.  Settings are:
    # 0: disable all list compression
    # 1: depth 1 means "don't start compressing until after 1 node into the list,
    #    going from either the head or tail"
    #    So: [head]->node->node->...->node->[tail]
    #    [head], [tail] will always be uncompressed; inner nodes will compress.
    # 2: [head]->[next]->node->node->...->node->[prev]->[tail]
    #    2 here means: don't compress head or head->next or tail->prev or tail,
    #    but compress all nodes between them.
    # 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
    # etc.
    list-compress-depth 0

    # Sets have a special encoding in just one case: when a set is composed
    # of just strings that happen to be integers in radix 10 in the range
    # of 64 bit signed integers.
    # The following configuration setting sets the limit in the size of the
    # set in order to use this special memory saving encoding.
    set-max-intset-entries 512

    # Similarly to hashes and lists, sorted sets are also specially encoded in
    # order to save a lot of space. This encoding is only used when the length and
    # elements of a sorted set are below the following limits:
    zset-max-ziplist-entries 128
    zset-max-ziplist-value 64

    # HyperLogLog sparse representation bytes limit. The limit includes the
    # 16 bytes header. When an HyperLogLog using the sparse representation crosses
    # this limit, it is converted into the dense representation.
    #
    # A value greater than 16000 is totally useless, since at that point the
    # dense representation is more memory efficient.
    #
    # The suggested value is ~ 3000 in order to have the benefits of
    # the space efficient encoding without slowing down too much PFADD,
    # which is O(N) with the sparse encoding. The value can be raised to
    # ~ 10000 when CPU is not a concern, but space is, and the data set is
    # composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
    hll-sparse-max-bytes 3000

    # Streams macro node max size / items. The stream data structure is a radix
    # tree of big nodes that encode multiple items inside. Using this configuration
    # it is possible to configure how big a single node can be in bytes, and the
    # maximum number of items it may contain before switching to a new node when
    # appending new stream entries. If any of the following settings are set to
    # zero, the limit is ignored, so for instance it is possible to set just a
    # max entries limit by setting max-bytes to 0 and max-entries to the desired
    # value.
    stream-node-max-bytes 4096
    stream-node-max-entries 100

    # Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
    # order to help rehashing the main Redis hash table (the one mapping top-level
    # keys to values). The hash table implementation Redis uses (see dict.c)
    # performs a lazy rehashing: the more operation you run into a hash table
    # that is rehashing, the more rehashing "steps" are performed, so if the
    # server is idle the rehashing is never complete and some more memory is used
    # by the hash table.
    #
    # The default is to use this millisecond 10 times every second in order to
    # actively rehash the main dictionaries, freeing memory when possible.
    #
    # If unsure:
    # use "activerehashing no" if you have hard latency requirements and it is
    # not a good thing in your environment that Redis can reply from time to time
    # to queries with 2 milliseconds delay.
    #
    # use "activerehashing yes" if you don't have such hard requirements but
    # want to free memory asap when possible.
    activerehashing yes

    # The client output buffer limits can be used to force disconnection of clients
    # that are not reading data from the server fast enough for some reason (a
    # common reason is that a Pub/Sub client can't consume messages as fast as the
    # publisher can produce them).
    #
    # The limit can be set differently for the three different classes of clients:
    #
    # normal -> normal clients including MONITOR clients
    # replica  -> replica clients
    # pubsub -> clients subscribed to at least one pubsub channel or pattern
    #
    # The syntax of every client-output-buffer-limit directive is the following:
    #
    # client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
    #
    # A client is immediately disconnected once the hard limit is reached, or if
    # the soft limit is reached and remains reached for the specified number of
    # seconds (continuously).
    # So for instance if the hard limit is 32 megabytes and the soft limit is
    # 16 megabytes / 10 seconds, the client will get disconnected immediately
    # if the size of the output buffers reach 32 megabytes, but will also get
    # disconnected if the client reaches 16 megabytes and continuously overcomes
    # the limit for 10 seconds.
    #
    # By default normal clients are not limited because they don't receive data
    # without asking (in a push way), but just after a request, so only
    # asynchronous clients may create a scenario where data is requested faster
    # than it can read.
    #
    # Instead there is a default limit for pubsub and replica clients, since
    # subscribers and replicas receive data in a push fashion.
    #
    # Both the hard or the soft limit can be disabled by setting them to zero.
    client-output-buffer-limit normal 0 0 0
    client-output-buffer-limit replica 256mb 64mb 60
    client-output-buffer-limit pubsub 32mb 8mb 60

    # Client query buffers accumulate new commands. They are limited to a fixed
    # amount by default in order to avoid that a protocol desynchronization (for
    # instance due to a bug in the client) will lead to unbound memory usage in
    # the query buffer. However you can configure it here if you have very special
    # needs, such us huge multi/exec requests or alike.
    #
    # client-query-buffer-limit 1gb

    # In the Redis protocol, bulk requests, that are, elements representing single
    # strings, are normally limited to 512 mb. However you can change this limit
    # here.
    #
    # proto-max-bulk-len 512mb

    # Redis calls an internal function to perform many background tasks, like
    # closing connections of clients in timeout, purging expired keys that are
    # never requested, and so forth.
    #
    # Not all tasks are performed with the same frequency, but Redis checks for
    # tasks to perform according to the specified "hz" value.
    #
    # By default "hz" is set to 10. Raising the value will use more CPU when
    # Redis is idle, but at the same time will make Redis more responsive when
    # there are many keys expiring at the same time, and timeouts may be
    # handled with more precision.
    #
    # The range is between 1 and 500, however a value over 100 is usually not
    # a good idea. Most users should use the default of 10 and raise this up to
    # 100 only in environments where very low latency is required.
    hz 10

    # Normally it is useful to have an HZ value which is proportional to the
    # number of clients connected. This is useful in order, for instance, to
    # avoid too many clients are processed for each background task invocation
    # in order to avoid latency spikes.
    #
    # Since the default HZ value by default is conservatively set to 10, Redis
    # offers, and enables by default, the ability to use an adaptive HZ value
    # which will temporary raise when there are many connected clients.
    #
    # When dynamic HZ is enabled, the actual configured HZ will be used
    # as a baseline, but multiples of the configured HZ value will be actually
    # used as needed once more clients are connected. In this way an idle
    # instance will use very little CPU time while a busy instance will be
    # more responsive.
    dynamic-hz yes

    # When a child rewrites the AOF file, if the following option is enabled
    # the file will be fsync-ed every 32 MB of data generated. This is useful
    # in order to commit the file to the disk more incrementally and avoid
    # big latency spikes.
    aof-rewrite-incremental-fsync yes

    # When redis saves RDB file, if the following option is enabled
    # the file will be fsync-ed every 32 MB of data generated. This is useful
    # in order to commit the file to the disk more incrementally and avoid
    # big latency spikes.
    rdb-save-incremental-fsync yes

    # Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
    # idea to start with the default settings and only change them after investigating
    # how to improve the performances and how the keys LFU change over time, which
    # is possible to inspect via the OBJECT FREQ command.
    #
    # There are two tunable parameters in the Redis LFU implementation: the
    # counter logarithm factor and the counter decay time. It is important to
    # understand what the two parameters mean before changing them.
    #
    # The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
    # uses a probabilistic increment with logarithmic behavior. Given the value
    # of the old counter, when a key is accessed, the counter is incremented in
    # this way:
    #
    # 1. A random number R between 0 and 1 is extracted.
    # 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
    # 3. The counter is incremented only if R < P.
    #
    # The default lfu-log-factor is 10. This is a table of how the frequency
    # counter changes with a different number of accesses with different
    # logarithmic factors:
    #
    # +--------+------------+------------+------------+------------+------------+
    # | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
    # +--------+------------+------------+------------+------------+------------+
    # | 0      | 104        | 255        | 255        | 255        | 255        |
    # +--------+------------+------------+------------+------------+------------+
    # | 1      | 18         | 49         | 255        | 255        | 255        |
    # +--------+------------+------------+------------+------------+------------+
    # | 10     | 10         | 18         | 142        | 255        | 255        |
    # +--------+------------+------------+------------+------------+------------+
    # | 100    | 8          | 11         | 49         | 143        | 255        |
    # +--------+------------+------------+------------+------------+------------+
    #
    # NOTE: The above table was obtained by running the following commands:
    #
    #   redis-benchmark -n 1000000 incr foo
    #   redis-cli object freq foo
    #
    # NOTE 2: The counter initial value is 5 in order to give new objects a chance
    # to accumulate hits.
    #
    # The counter decay time is the time, in minutes, that must elapse in order
    # for the key counter to be divided by two (or decremented if it has a value
    # less <= 10).
    #
    # The default value for the lfu-decay-time is 1. A Special value of 0 means to
    # decay the counter every time it happens to be scanned.
    #
    # lfu-log-factor 10
    # lfu-decay-time 1

    ########################### ACTIVE DEFRAGMENTATION #######################
    #
    # What is active defragmentation?
    # -------------------------------
    #
    # Active (online) defragmentation allows a Redis server to compact the
    # spaces left between small allocations and deallocations of data in memory,
    # thus allowing to reclaim back memory.
    #
    # Fragmentation is a natural process that happens with every allocator (but
    # less so with Jemalloc, fortunately) and certain workloads. Normally a server
    # restart is needed in order to lower the fragmentation, or at least to flush
    # away all the data and create it again. However thanks to this feature
    # implemented by Oran Agra for Redis 4.0 this process can happen at runtime
    # in an "hot" way, while the server is running.
    #
    # Basically when the fragmentation is over a certain level (see the
    # configuration options below) Redis will start to create new copies of the
    # values in contiguous memory regions by exploiting certain specific Jemalloc
    # features (in order to understand if an allocation is causing fragmentation
    # and to allocate it in a better place), and at the same time, will release the
    # old copies of the data. This process, repeated incrementally for all the keys
    # will cause the fragmentation to drop back to normal values.
    #
    # Important things to understand:
    #
    # 1. This feature is disabled by default, and only works if you compiled Redis
    #    to use the copy of Jemalloc we ship with the source code of Redis.
    #    This is the default with Linux builds.
    #
    # 2. You never need to enable this feature if you don't have fragmentation
    #    issues.
    #
    # 3. Once you experience fragmentation, you can enable this feature when
    #    needed with the command "CONFIG SET activedefrag yes".
    #
    # The configuration parameters are able to fine tune the behavior of the
    # defragmentation process. If you are not sure about what they mean it is
    # a good idea to leave the defaults untouched.

    # Enabled active defragmentation
    # activedefrag no

    # Minimum amount of fragmentation waste to start active defrag
    # active-defrag-ignore-bytes 100mb

    # Minimum percentage of fragmentation to start active defrag
    # active-defrag-threshold-lower 10

    # Maximum percentage of fragmentation at which we use maximum effort
    # active-defrag-threshold-upper 100

    # Minimal effort for defrag in CPU percentage, to be used when the lower
    # threshold is reached
    # active-defrag-cycle-min 1

    # Maximal effort for defrag in CPU percentage, to be used when the upper
    # threshold is reached
    # active-defrag-cycle-max 25

    # Maximum number of set/hash/zset/list fields that will be processed from
    # the main dictionary scan
    # active-defrag-max-scan-fields 1000

    # Jemalloc background thread for purging will be enabled by default
    jemalloc-bg-thread yes

    # It is possible to pin different threads and processes of Redis to specific
    # CPUs in your system, in order to maximize the performances of the server.
    # This is useful both in order to pin different Redis threads in different
    # CPUs, but also in order to make sure that multiple Redis instances running
    # in the same host will be pinned to different CPUs.
    #
    # Normally you can do this using the "taskset" command, however it is also
    # possible to this via Redis configuration directly, both in Linux and FreeBSD.
    #
    # You can pin the server/IO threads, bio threads, aof rewrite child process, and
    # the bgsave child process. The syntax to specify the cpu list is the same as
    # the taskset command:
    #
    # Set redis server/io threads to cpu affinity 0,2,4,6:
    # server_cpulist 0-7:2
    #
    # Set bio threads to cpu affinity 1,3:
    # bio_cpulist 1,3
    #
    # Set aof rewrite child process to cpu affinity 8,9,10,11:
    # aof_rewrite_cpulist 8-11
    #
    # Set bgsave child process to cpu affinity 1,10,11
    # bgsave_cpulist 1,10-11
    loadmodule /redismodules/redisearch.so OSS_GLOBAL_PASSWORD p@ssw0rd!
---
# Source: kube-acp-stack/charts/redis-cluster/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-cluster-scripts
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
data:
  ping_readiness_local.sh: |-
    #!/bin/sh
    set -e

    REDIS_STATUS_FILE=/tmp/.redis_cluster_check
    if [ ! -z "$REDIS_PASSWORD" ]; then export REDISCLI_AUTH=$REDIS_PASSWORD; fi;
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
    if [ ! -f "$REDIS_STATUS_FILE" ]; then
      response=$(
        timeout -s 3 $1 \
        redis-cli \
          -h localhost \
          -p $REDIS_PORT \
          CLUSTER INFO | grep cluster_state | tr -d '[:space:]'
      )
      if [ "$?" -eq "124" ]; then
        echo "Timed out"
        exit 1
      fi
      if [ "$response" != "cluster_state:ok" ]; then
        echo "$response"
        exit 1
      else
        touch "$REDIS_STATUS_FILE"
      fi
    fi
  ping_liveness_local.sh: |-
    #!/bin/sh
    set -e
    if [ ! -z "$REDIS_PASSWORD" ]; then export REDISCLI_AUTH=$REDIS_PASSWORD; fi;
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')
    if [ "$response" != "PONG" ] && [ "$responseFirstWord" != "LOADING" ] && [ "$responseFirstWord" != "MASTERDOWN" ]; then
      echo "$response"
      exit 1
    fi
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/configmap-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.---
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-patroni
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: patroni
data:
  patroni.yaml: |
    bootstrap:
      dcs:
        loop_wait: 10
        maximum_lag_on_failover: 33554432
        postgresql:
          parameters:
            archive_command: /etc/timescaledb/scripts/pgbackrest_archive.sh %p
            archive_mode: "on"
            archive_timeout: 1800s
            autovacuum_analyze_scale_factor: 0.02
            autovacuum_max_workers: 10
            autovacuum_naptime: 5s
            autovacuum_vacuum_cost_limit: 500
            autovacuum_vacuum_scale_factor: 0.05
            hot_standby: "on"
            log_autovacuum_min_duration: 1min
            log_checkpoints: "on"
            log_connections: "on"
            log_disconnections: "on"
            log_line_prefix: '%t [%p]: [%c-%l] %u@%d,app=%a [%e] '
            log_lock_waits: "on"
            log_min_duration_statement: 1s
            log_statement: ddl
            max_connections: 100
            max_prepared_transactions: 150
            shared_preload_libraries: timescaledb,pg_stat_statements
            ssl: "on"
            ssl_cert_file: /etc/certificate/tls.crt
            ssl_key_file: /etc/certificate/tls.key
            tcp_keepalives_idle: 900
            tcp_keepalives_interval: 100
            temp_file_limit: 1GB
            timescaledb.passfile: ../.pgpass
            unix_socket_directories: /var/run/postgresql
            unix_socket_permissions: "0750"
            wal_level: hot_standby
            wal_log_hints: "on"
          use_pg_rewind: true
          use_slots: true
        retry_timeout: 10
        ttl: 30
      method: restore_or_initdb
      post_init: /etc/timescaledb/scripts/post_init.sh
      restore_or_initdb:
        command: |
          /etc/timescaledb/scripts/restore_or_initdb.sh --encoding=UTF8 --locale=C.UTF-8
        keep_existing_recovery_conf: true
    kubernetes:
      role_label: role
      scope_label: cluster-name
      use_endpoints: true
    log:
      level: WARNING
    postgresql:
      authentication:
        replication:
          username: standby
        superuser:
          username: postgres
      basebackup:
      - waldir: /var/lib/postgresql/wal/pg_wal
      callbacks:
        on_reload: /etc/timescaledb/scripts/patroni_callback.sh
        on_restart: /etc/timescaledb/scripts/patroni_callback.sh
        on_role_change: /etc/timescaledb/scripts/patroni_callback.sh
        on_start: /etc/timescaledb/scripts/patroni_callback.sh
        on_stop: /etc/timescaledb/scripts/patroni_callback.sh
      create_replica_methods:
      - pgbackrest
      - basebackup
      listen: 0.0.0.0:5432
      pg_hba:
      - local     all             postgres                              peer
      - local     all             all                                   md5
      - hostnossl all,replication all                all                reject
      - hostssl   all             all                127.0.0.1/32       md5
      - hostssl   all             all                ::1/128            md5
      - hostssl   replication     standby            all                md5
      - hostssl   all             all                all                md5
      pgbackrest:
        command: /etc/timescaledb/scripts/pgbackrest_restore.sh
        keep_data: true
        no_master: true
        no_params: true
      recovery_conf:
        restore_command: /etc/timescaledb/scripts/pgbackrest_archive_get.sh %f "%p"
      use_unix_socket: true
    restapi:
      listen: 0.0.0.0:8008
...
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/configmap-pgbackrest.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-pgbackrest
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: pgbackrest
data:
  pgbackrest.conf: |
    [global]
    compress-level=3
    compress-type=lz4
    process-max=4
    repo1-cipher-type=none
    repo1-path=/default/timescaledb/
    repo1-retention-diff=2
    repo1-retention-full=2
    spool-path=/var/run/postgresql
    start-fast=y

    [poddb]
    pg1-port=5432
    pg1-host-user=postgres
    pg1-path=/var/lib/postgresql/data
    pg1-socket-path=/var/run/postgresql

    link-all=y

    [global:archive-push]

    [global:archive-get]
...
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/configmap-scripts.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.---
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-scripts
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: scripts
data:
  tstune.sh: |-
    #!/bin/sh
    
    set -eu
    
    # Exit if required variable is not set externally
    : "$TSTUNE_FILE"
    : "$WAL_VOLUME_SIZE"
    : "$DATA_VOLUME_SIZE"
    : "$RESOURCES_CPU_REQUESTS"
    : "$RESOURCES_MEMORY_REQUESTS"
    : "$RESOURCES_CPU_LIMIT"
    : "$RESOURCES_MEMORY_LIMIT"
    
    # Figure out how many cores are available
    CPUS="$RESOURCES_CPU_REQUESTS"
    if [ "$RESOURCES_CPU_REQUESTS" -eq 0 ]; then
        CPUS="${RESOURCES_CPU_LIMIT}"
    fi
    # Figure out how much memory is available
    MEMORY="$RESOURCES_MEMORY_REQUESTS"
    if [ "$RESOURCES_MEMORY_REQUESTS" -eq 0 ]; then
        MEMORY="${RESOURCES_MEMORY_LIMIT}"
    fi
    
    # Ensure tstune config file exists
    touch "${TSTUNE_FILE}"
    
    # Ensure tstune-generated config is included in postgresql.conf
    if [ -f "${PGDATA}/postgresql.base.conf" ] && ! grep "include_if_exists = '${TSTUNE_FILE}'" postgresql.base.conf -qxF; then
        echo "include_if_exists = '${TSTUNE_FILE}'" >> "${PGDATA}/postgresql.base.conf"
    fi
    
    # If there is a dedicated WAL Volume, we want to set max_wal_size to 60% of that volume
    # If there isn't a dedicated WAL Volume, we set it to 20% of the data volume
    if [ "${WAL_VOLUME_SIZE}" = "0" ]; then
        WALMAX="${DATA_VOLUME_SIZE}"
        WALPERCENT=20
    else
        WALMAX="${WAL_VOLUME_SIZE}"
        WALPERCENT=60
    fi
    
    WALMAX=$(numfmt --from=auto "${WALMAX}")
    
    # Wal segments are 16MB in size, in this way we get a "nice" number of the nearest
    # 16MB
    # walmax / 100 * walpercent / 16MB # below is a refactored with increased precision
    WALMAX=$(( WALMAX * WALPERCENT * 16 / 16777216 / 100  ))
    WALMIN=$(( WALMAX / 2 ))
    
    echo "max_wal_size=${WALMAX}MB" >> "${TSTUNE_FILE}"
    echo "min_wal_size=${WALMIN}MB" >> "${TSTUNE_FILE}"
    
    # Run tstune
    timescaledb-tune -quiet -conf-path "${TSTUNE_FILE}" -cpus "${CPUS}" -memory "${MEMORY}MB" -yes "$@"
    
  pgbackrest_archive.sh: |-
    #!/bin/sh
    
    # If no backup is configured, archive_command would normally fail. A failing archive_command on a cluster
    # is going to cause WAL to be kept around forever, meaning we'll fill up Volumes we have quite quickly.
    #
    # Therefore, if the backup is disabled, we always return exitcode 0 when archiving
    
    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - archive - $1"
    }
    
    [ -z "$1" ] && log "Usage: $0 <WALFILE or DIRECTORY>" && exit 1
    
    : "${ENV_FILE:=${HOME}/.pgbackrest_environment}"
    if [ -f "${ENV_FILE}" ]; then
        echo "Sourcing ${ENV_FILE}"
        . "${ENV_FILE}"
    fi
    
    # PGBACKREST_BACKUP_ENABLED variable is passed in StatefulSet template
    [ "${PGBACKREST_BACKUP_ENABLED}" = "true" ] || exit 0
    
    exec pgbackrest --stanza=poddb archive-push "$@"
    
  pgbackrest_archive_get.sh: |-
    #!/bin/sh
    # PGBACKREST_BACKUP_ENABLED variable is passed in StatefulSet template
    [ "${PGBACKREST_BACKUP_ENABLED}" = "true" ] || exit 1
    
    : "${ENV_FILE:=${HOME}/.pgbackrest_environment}"
    if [ -f "${ENV_FILE}" ]; then
    echo "Sourcing ${ENV_FILE}"
    . "${ENV_FILE}"
    fi
    
    exec pgbackrest --stanza=poddb archive-get "${1}" "${2}"
    
  pgbackrest_bootstrap.sh: |-
    #!/bin/sh
    set -e
    
    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - bootstrap - $1"
    }
    
    terminate() {
        log "Stopping"
        exit 1
    }
    # If we don't catch these signals, and we're still waiting for PostgreSQL
    # to be ready, we will not respond at all to a regular shutdown request,
    # therefore, we explicitly terminate if we receive these signals.
    trap terminate TERM QUIT
    
    while ! pg_isready -q; do
        log "Waiting for PostgreSQL to become available"
        sleep 3
    done
    
    # We'll be lazy; we wait for another while to allow the database to promote
    # to primary if it's the only one running
    sleep 10
    
    # If we are the primary, we want to create/validate the backup stanza
    if [ "$(psql -c "SELECT pg_is_in_recovery()::text" -AtXq)" = "false" ]; then
        pgbackrest check || {
            log "Creating pgBackrest stanza"
            pgbackrest --stanza=poddb stanza-create --log-level-stderr=info || exit 1
            log "Creating initial backup"
            pgbackrest --type=full backup || exit 1
        }
    fi
    
    log "Starting pgBackrest api to listen for backup requests"
    exec python3 /scripts/pgbackrest-rest.py --stanza=poddb --loglevel=debug
    
  pgbackrest_restore.sh: |
    #!/bin/sh
    # PGBACKREST_BACKUP_ENABLED variable is passed in StatefulSet template
    [ "${PGBACKREST_BACKUP_ENABLED}" = "true" ] || exit 1
    
    : "${ENV_FILE:=${HOME}/.pod_environment}"
    if [ -f "${ENV_FILE}" ]; then
    echo "Sourcing ${ENV_FILE}"
    . "${ENV_FILE}"
    fi
    
    # PGDATA and WALDIR are set in the StatefulSet template and are sourced from the ENV_FILE
    # PGDATA=
    # WALDIR=
    
    # A missing PGDATA points to Patroni removing a botched PGDATA, or manual
    # intervention. In this scenario, we need to recreate the DATA and WALDIRs
    # to keep pgBackRest happy
    [ -d "${PGDATA}" ] || install -o postgres -g postgres -d -m 0700 "${PGDATA}"
    [ -d "${WALDIR}" ] || install -o postgres -g postgres -d -m 0700 "${WALDIR}"
    
    exec pgbackrest --force --delta --log-level-console=detail restore
    
  restore_or_initdb.sh: |
    #!/bin/sh
    
    : "${ENV_FILE:=${HOME}/.pod_environment}"
    if [ -f "${ENV_FILE}" ]; then
        echo "Sourcing ${ENV_FILE}"
        . "${ENV_FILE}"
    fi
    
    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - restore_or_initdb - $1"
    }
    
    # PGDATA and WALDIR are set in the StatefulSet template and are sourced from the ENV_FILE
    # PGDATA=
    # WALDIR=
    
    # A missing PGDATA points to Patroni removing a botched PGDATA, or manual
    # intervention. In this scenario, we need to recreate the DATA and WALDIRs
    # to keep pgBackRest happy
    [ -d "${PGDATA}" ] || install -o postgres -g postgres -d -m 0700 "${PGDATA}"
    [ -d "${WALDIR}" ] || install -o postgres -g postgres -d -m 0700 "${WALDIR}"
    
    if [ "${BOOTSTRAP_FROM_BACKUP}" = "1" ]; then
        log "Attempting restore from backup"
        # we want to override the environment with the environment
        # shellcheck disable=SC2046
        export $(env -i envdir /etc/pgbackrest/bootstrap env) > /dev/null
        # PGBACKREST_REPO1_PATH is set in the StatefulSet template and sourced from the ENV_FILE
    
        if [ -z "${PGBACKREST_REPO1_PATH}" ]; then
            log "Unconfigured repository path"
            cat << "__EOT__"
    
    TimescaleDB Single Helm Chart error:
    
    You should configure the bootstrapFromBackup in your Helm Chart section by explicitly setting
    the repo1-path to point to the backups.
    
    For more information, consult the admin guide:
    https://github.com/timescale/helm-charts/blob/main/charts/timescaledb-single/docs/admin-guide.md#bootstrap-from-backup
    
    __EOT__
    
            exit 1
        fi
    
        log "Listing available backup information"
        pgbackrest info
        EXITCODE=$?
        if [ ${EXITCODE} -ne 0 ]; then
            exit $EXITCODE
        fi
    
        pgbackrest --log-level-console=detail restore
        EXITCODE=$?
        if [ ${EXITCODE} -eq 0 ]; then
            log "pgBackRest restore finished succesfully, starting instance in recovery"
            # We want to ensure we do not overwrite a current backup repository with archives, therefore
            # we block archiving from succeeding until Patroni can takeover
            touch "${PGDATA}/recovery.signal"
            pg_ctl -D "${PGDATA}" start -o '--archive-command=/bin/false'
    
            while ! pg_isready -q; do
                log "Waiting for PostgreSQL to become available"
                sleep 3
            done
    
            # It is not trivial to figure out to what point we should restore, pgBackRest
            # should be fetching WAL segments until the WAL is exhausted. We'll ask pgBackRest
            # what the Maximum Wal is that it currently has; as soon as we see that, we can consider
            # the restore to be done
            while true; do
                MAX_BACKUP_WAL="$(pgbackrest info --output=json | python3 -c "import json,sys;obj=json.load(sys.stdin); print(obj[0]['archive'][0]['max']);")"
                log "Testing whether WAL file ${MAX_BACKUP_WAL} has been restored ..."
                [ -f "${PGDATA}/pg_wal/${MAX_BACKUP_WAL}" ] && break
                sleep 30;
            done
    
            # At this point we know the final WAL archive has been restored, we should be done.
            log "The WAL file ${MAX_BACKUP_WAL} has been successully restored, shutting down instance"
            pg_ctl -D "${PGDATA}" promote
            pg_ctl -D "${PGDATA}" stop -m fast
            log "Handing over control to Patroni ..."
        else
            log "Bootstrap from backup failed"
            exit 1
        fi
    else
        # Patroni attaches --scope and --datadir to the arguments, we need to strip them off as
        # initdb has no business with these parameters
        initdb_args=""
        for value in "$@"
        do
            case $value in
                "--scope"*)
                    ;;
                "--datadir"*)
                    ;;
                *)
                    initdb_args="${initdb_args} $value"
                    ;;
            esac
        done
    
        log "Invoking initdb"
        # shellcheck disable=SC2086
        initdb --auth-local=peer --auth-host=md5 --pgdata="${PGDATA}" --waldir="${WALDIR}" ${initdb_args}
    fi
    
    echo "include_if_exists = '${TSTUNE_FILE}'" >> "${PGDATA}/postgresql.conf"
    
  post_init.sh: |-
    #!/bin/sh
    : "${ENV_FILE:=${HOME}/.pod_environment}"
    if [ -f "${ENV_FILE}" ]; then
        echo "Sourcing ${ENV_FILE}"
        . "${ENV_FILE}"
    fi
    
    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - post_init - $1"
    }
    
    log "Creating extension TimescaleDB in template1 and postgres databases"
    psql -d "$URL" <<__SQL__
        \connect template1
        -- As we're still only initializing, we cannot have synchronous_commit enabled just yet.
        SET synchronous_commit to 'off';
        CREATE EXTENSION timescaledb;
    
        \connect postgres
        SET synchronous_commit to 'off';
        CREATE EXTENSION timescaledb;
    __SQL__
    
    # POSTGRES_TABLESPACES is a comma-separated list of tablespaces to create
    # variable is passed in StatefulSet template
    : "${POSTGRES_TABLESPACES:=""}"
    for tablespace in $POSTGRES_TABLESPACES
    do
        log "Creating tablespace ${tablespace}"
        tablespacedir="${PGDATA}/tablespaces/${tablespace}/data"
        psql -d "$URL" --set tablespace="${tablespace}" --set directory="${tablespacedir}" --set ON_ERROR_STOP=1 <<__SQL__
        SET synchronous_commit to 'off';
        CREATE TABLESPACE :"tablespace" LOCATION :'directory';
    __SQL__
    done
    
    # This directory may contain user defined post init steps
    for file in /etc/timescaledb/post_init.d/*
    do
        [ -d "$file" ] && continue
        [ ! -r "$file" ] && continue
    
        case "$file" in
        *.sh)
            if [ -x "$file" ]; then
            log "Call post init script [ $file ]"
            "$file" "$@"
            EXITCODE=$?
            else
            log "Source post init script [ $file ]"
            . "$file"
            EXITCODE=$?
            fi
            ;;
        *.sql)
            log "Apply post init sql [ $file ]"
            # Disable synchronous_commit since we're initializing
            PGOPTIONS="-c synchronous_commit=local" psql -d "$URL" -f "$file"
            EXITCODE=$?
            ;;
        *.sql.gz)
            log "Decompress and apply post init sql [ $file ]"
            gunzip -c "$file" | PGOPTIONS="-c synchronous_commit=local" psql -d "$URL"
            EXITCODE=$?
            ;;
        *)
            log "Ignore unknown post init file type [ $file ]"
            EXITCODE=0
            ;;
        esac
        EXITCODE=$?
        if [ "$EXITCODE" != "0" ]
        then
            log "ERROR: post init script $file exited with exitcode $EXITCODE"
            exit $EXITCODE
        fi
    done
    
    # We exit 0 this script, otherwise the database initialization fails.
    exit 0
    
  patroni_callback.sh: |-
    #!/bin/sh
    set -e
    
    : "${ENV_FILE:=${HOME}/.pod_environment}"
    if [ -f "${ENV_FILE}" ]; then
        echo "Sourcing ${ENV_FILE}"
        . "${ENV_FILE}"
    fi
    
    for suffix in "$1" all
    do
        CALLBACK="/etc/timescaledb/callbacks/${suffix}"
        if [ -f "${CALLBACK}" ]
        then
        "${CALLBACK}" "$@"
        fi
    done
    
  lifecycle_preStop.sql: |-
    -- Doing a checkpoint (at the primary and the current instance) before starting
    -- the shutdown process will speed up the CHECKPOINT that is part of the shutdown
    -- process and the recovery after the pod is rescheduled.
    --
    -- We issue the CHECKPOINT at the primary always because:
    --
    -- > Restartpoints can't be performed more frequently than checkpoints in the
    -- > master because restartpoints can only be performed at checkpoint records.
    -- https://www.postgresql.org/docs/current/wal-configuration.html
    --
    -- While we're doing these preStop CHECKPOINTs we can still serve read/write
    -- queries to clients, whereas as soon as we initiate the shutdown, we terminate
    -- connections.
    --
    -- This therefore reduces downtime for the clients, at the cost of increasing (slightly)
    -- the time to stop the pod, and reducing write performance on the primary.
    --
    -- To further reduce downtime for clients, we will issue a switchover iff we are currently
    -- running as the primary. This again should be relatively fast, as we've just issued and
    -- waited for the CHECKPOINT to complete.
    --
    -- This is quite a lot of logic and work in a preStop command; however, if the preStop command
    -- fails for whatever reason, the normal Pod shutdown will commence, so it is only able to
    -- improve stuff without being able to break stuff.
    -- (The $(hostname) inside the switchover call safeguards that we never accidentally
    -- switchover the wrong primary).
    
    \pset pager off
    \set ON_ERROR_STOP true
    \set hostname `hostname`
    \set dsn_fmt 'user=postgres host=%s application_name=lifecycle:preStop@%s connect_timeout=5 options=''-c log_min_duration_statement=0'''
    
    SELECT
        pg_is_in_recovery() AS in_recovery,
        format(:'dsn_fmt', patroni_scope,                       :'hostname') AS primary_dsn,
        format(:'dsn_fmt', '/var/run/postgresql', :'hostname') AS local_dsn
    FROM
        current_setting('cluster_name') AS cs(patroni_scope)
    \gset
    
    \timing on
    \set ECHO queries
    
    -- There should be a CHECKPOINT at the primary
    \if :in_recovery
        \connect :"primary_dsn"
        CHECKPOINT;
    \endif
    
    -- There should also be a CHECKPOINT locally,
    -- for the primary, this may mean we do a double checkpoint,
    -- but the second one would be cheap anyway, so we leave that as is
    \connect :"local_dsn"
    SELECT 'Issuing checkpoint';
    CHECKPOINT;
    
    \if :in_recovery
        SELECT 'We are a replica: Successfully invoked checkpoints at the primary and locally.';
    \else
        SELECT 'We are a primary: Successfully invoked checkpoints, now issuing a switchover.';
        \! curl -s http://localhost:8008/switchover -XPOST -d '{"leader": "$(hostname)"}'
    \endif
    
...
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/role-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: timescaledb
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: rbac
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs:
  - create
  - get
  - list
  - patch
  - update
  - watch
  # delete is required only for 'patronictl remove'
  - delete
- apiGroups: [""]
  resources:
  - endpoints
  - endpoints/restricted
  verbs:
  - create
  - get
  - patch
  - update
  # the following three privileges are necessary only when using endpoints
  - list
  - watch
  # delete is required only for for 'patronictl remove'
  - delete
- apiGroups: [""]
  resources: ["pods"]
  verbs:
  - get
  - list
  - patch
  - update
  - watch
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/rolebinding-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: timescaledb
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: rbac
subjects:
  - kind: ServiceAccount
    name: timescaledb
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: timescaledb
---
# Source: kube-acp-stack/charts/acp/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
    - port: 8443
      targetPort: http
      protocol: TCP
      name: http
    - port: 9000
      targetPort: metrics
      protocol: TCP
      name: metrics
    - port: 9443
      targetPort: grpc
      protocol: TCP
      name: grpc
  selector:
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
---
# Source: kube-acp-stack/charts/cockroachdb/templates/service.discovery.yaml
# This service only exists to create DNS entries for each pod in
# the StatefulSet such that they can resolve each other's IP addresses.
# It does not create a load-balanced ClusterIP and should not be used directly
# by clients in most circumstances.
kind: Service
apiVersion: v1
metadata:
  name: cockroachdb
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/component: cockroachdb
  annotations:
    # Use this annotation in addition to the actual field below because the
    # annotation will stop being respected soon, but the field is broken in
    # some versions of Kubernetes:
    # https://github.com/kubernetes/kubernetes/issues/58662
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    # Enable automatic monitoring of all instances when Prometheus is running
    # in the cluster.
    prometheus.io/scrape: "true"
    prometheus.io/path: _status/vars
    prometheus.io/port: "8080"
spec:
  clusterIP: None
  # We want all Pods in the StatefulSet to have their addresses published for
  # the sake of the other CockroachDB Pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    # The main port, served by gRPC, serves Postgres-flavor SQL, inter-node
    # traffic and the CLI.
    - name: "grpc"
      port: 26257
      targetPort: grpc
    # The secondary port serves the UI as well as health and debug endpoints.
    - name: "http"
      port: 8080
      targetPort: http
  selector:
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/component: cockroachdb
---
# Source: kube-acp-stack/charts/cockroachdb/templates/service.public.yaml
# This Service is meant to be used by clients of the database.
# It exposes a ClusterIP that will automatically load balance connections
# to the different database Pods.
kind: Service
apiVersion: v1
metadata:
  name: cockroachdb-public
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/component: cockroachdb
spec:
  type: "ClusterIP"
  ports:
    # The main port, served by gRPC, serves Postgres-flavor SQL, inter-node
    # traffic and the CLI.
    - name: "grpc"
      port: 26257
      targetPort: grpc
    # The secondary port serves the UI as well as health and debug endpoints.
    - name: "http"
      port: 8080
      targetPort: http
  selector:
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/component: cockroachdb
---
# Source: kube-acp-stack/charts/redis-cluster/templates/headless-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster-headless
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: tcp-redis
    - name: tcp-redis-bus
      port: 16379
      targetPort: tcp-redis-bus
  selector:
    app.kubernetes.io/name: redis-cluster
    app.kubernetes.io/instance: release-name
---
# Source: kube-acp-stack/charts/redis-cluster/templates/redis-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
  annotations:
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: tcp-redis
      protocol: TCP
      nodePort: null
  selector:
    app.kubernetes.io/name: redis-cluster
    app.kubernetes.io/instance: release-name
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/svc-timescaledb-config.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb-config
  namespace: default
  labels:
    component: patroni
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: patroni
spec:
  selector:
    app: timescaledb
    cluster-name: timescaledb
  type: ClusterIP
  clusterIP: None
  ports:
  - name: patroni
    port: 8008
    protocol: TCP
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/svc-timescaledb-replica.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb-replica
  namespace: default
  labels:
    component: postgres
    role: replica
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: postgres
spec:
  selector:
    app: timescaledb
    cluster-name: timescaledb
    role: replica
  type: ClusterIP
  ports:
  - name: postgresql
    # This always defaults to 5432
    port: 5432
    targetPort: postgresql
    protocol: TCP
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/svc-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb
  namespace: default
  labels:
    role: master
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: timescaledb
spec:
  selector:
    app: timescaledb
    cluster-name: timescaledb
    role: master
  type: ClusterIP
  ports:
  - name: postgresql
    # This always defaults to 5432
    port: 5432
    targetPort: postgresql
    protocol: TCP
---
# Source: kube-acp-stack/charts/acp/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: acp
      app.kubernetes.io/instance: release-name
  template:
    metadata:
      labels:
        app.kubernetes.io/name: acp
        app.kubernetes.io/instance: release-name
    spec:
      imagePullSecrets:
        - name: docker.cloudentity.io
      volumes:
        - name: data
          configMap:
            name: release-name-acp
        - name: tls
          projected:
            defaultMode: 384
            sources:
            - secret:
                name: release-name-acp-tls
        - name: secret
          secret:
            secretName: release-name-acp
      serviceAccountName: release-name-acp
      securityContext:
        fsGroup: 65535
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: acp
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 65535
            runAsNonRoot: true
            runAsUser: 65535
          image: "docker.cloudentity.io/acp-distroless:2.21.0"
          imagePullPolicy: IfNotPresent
          args:
            - server
            - start
            - --demo
            - --metrics
            - --create-default-tenant
            - --create-default-workspaces
            - --config
            - /data/config.yaml,/data/extraconfig.yaml,/secret/config.yaml
            
          env:
            - name: SERVER_DISABLE_ASYNC_PROCESSING
              value: "false"
            - name: SQL_MIGRATIONS_DISABLE
              value: "false"
          ports:
            - name: http
              containerPort: 8443
              protocol: TCP
            - name: metrics
              containerPort: 9000
              protocol: TCP
            - name: grpc
              containerPort: 9443
              protocol: TCP
          startupProbe:
            httpGet:
              path: /alive
              scheme: HTTPS
              port: 8443
            failureThreshold: 10
            periodSeconds: 10
            timeoutSeconds: 10
          readinessProbe:
            httpGet:
              path: /alive
              scheme: HTTPS
              port: 8443
            initialDelaySeconds: 5
            failureThreshold: 3
            periodSeconds: 10
            timeoutSeconds: 10
          livenessProbe:
            httpGet:
              path: /alive
              scheme: HTTPS
              port: 8443
            initialDelaySeconds: 3
            failureThreshold: 10
            periodSeconds: 10
            timeoutSeconds: 10
          volumeMounts:
            - mountPath: /data
              name: data
              readOnly: true
            - mountPath: /tls
              name: tls
              readOnly: true
            - mountPath: /secret
              name: secret
              readOnly: true
          resources:
            {}
---
# Source: kube-acp-stack/charts/cockroachdb/templates/statefulset.yaml
kind: StatefulSet
apiVersion: apps/v1
metadata:
  name: cockroachdb
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/component: cockroachdb
spec:
  serviceName: cockroachdb
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: "Parallel"
  selector:
    matchLabels:
      app.kubernetes.io/name: cockroachdb
      app.kubernetes.io/instance: "release-name"
      app.kubernetes.io/component: cockroachdb
  template:
    metadata:
      labels:
        app.kubernetes.io/name: cockroachdb
        app.kubernetes.io/instance: "release-name"
        app.kubernetes.io/component: cockroachdb
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: cockroachdb
                    app.kubernetes.io/instance: "release-name"
                    app.kubernetes.io/component: cockroachdb
      topologySpreadConstraints:
      - labelSelector:
          matchLabels:
            app.kubernetes.io/name: cockroachdb
            app.kubernetes.io/instance: "release-name"
            app.kubernetes.io/component: cockroachdb
        maxSkew: 1
        topologyKey: topology.kubernetes.io/zone
        whenUnsatisfiable: ScheduleAnyway
      # No pre-stop hook is required, a SIGTERM plus some time is all that's
      # needed for graceful shutdown of a node.
      terminationGracePeriodSeconds: 60
      containers:
        - name: db
          image: "cockroachdb/cockroach:v22.2.9"
          imagePullPolicy: "IfNotPresent"
          args:
            - shell
            - -ecx
            # The use of qualified `hostname -f` is crucial:
            # Other nodes aren't able to look up the unqualified hostname.
            #
            # `--join` CLI flag is hardcoded to exactly 3 Pods, because:
            # 1. Having `--join` value depending on `statefulset.replicas`
            #    will trigger undesired restart of existing Pods when
            #    StatefulSet is scaled up/down. We want to scale without
            #    restarting existing Pods.
            # 2. At least one Pod in `--join` is enough to successfully
            #    join CockroachDB cluster and gossip with all other existing
            #    Pods, even if there are 3 or more Pods.
            # 3. It's harmless for `--join` to have 3 Pods even for 1-Pod
            #    clusters, while it gives us opportunity to scale up even if
            #    some Pods of existing cluster are down (for whatever reason).
            # See details explained here:
            # https://github.com/helm/charts/pull/18993#issuecomment-558795102
            - >-
              exec /cockroach/cockroach
              start --join=${STATEFULSET_NAME}-0.${STATEFULSET_FQDN}:26257,${STATEFULSET_NAME}-1.${STATEFULSET_FQDN}:26257,${STATEFULSET_NAME}-2.${STATEFULSET_FQDN}:26257
              --advertise-host=$(hostname).${STATEFULSET_FQDN}
              --insecure
              --http-port=8080
              --port=26257
              --cache=25%
              --max-sql-memory=25%
              --logtostderr=INFO
          env:
            - name: STATEFULSET_NAME
              value: cockroachdb
            - name: STATEFULSET_FQDN
              value: cockroachdb.default.svc.cluster.local
            - name: COCKROACH_CHANNEL
              value: kubernetes-helm
          ports:
            - name: grpc
              containerPort: 26257
              protocol: TCP
            - name: http
              containerPort: 8080
              protocol: TCP
          volumeMounts:
            - name: datadir
              mountPath: /cockroach/cockroach-data/
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /health?ready=1
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            failureThreshold: 2
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
      volumes:
        - name: datadir
          persistentVolumeClaim:
            claimName: datadir
      securityContext:
        fsGroup: 1000
        runAsGroup: 1000
        runAsUser: 1000
        runAsNonRoot: true
  volumeClaimTemplates:
    - metadata:
        name: datadir
        labels:
          app.kubernetes.io/name: cockroachdb
          app.kubernetes.io/instance: "release-name"
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: "100Gi"
---
# Source: kube-acp-stack/charts/redis-cluster/templates/redis-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: "default"
  labels:
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-7.6.4
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
spec:
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: redis-cluster
      app.kubernetes.io/instance: release-name
  replicas: 3
  serviceName: redis-cluster-headless
  podManagementPolicy: Parallel
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis-cluster
        helm.sh/chart: redis-cluster-7.6.4
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
      annotations:
        checksum/scripts: f213b17da6349ab20b2010188919ebbcb38dfb7606640940a8f4651f2bfbfa3e
        checksum/secret: 3bb8d774551c7415dec6539c6d87b7a5d361cdf03a722b39f85ab88bcfd28e8f
        checksum/config: 19438e5db8f8d4a0205b460b5a7df3cc0e08eb335594ecec3cefb2785615ca58
    spec:
      hostNetwork: false
      enableServiceLinks: false
      
      securityContext:
        fsGroup: 1001
        runAsUser: 1001
        sysctls: []
      serviceAccountName: default
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis-cluster
                    app.kubernetes.io/instance: release-name
                namespaces:
                  - "default"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      containers:
        - name: redis-cluster
          image: docker.io/bitnami/redis-cluster:6.2.7-debian-11-r9
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
          command: ['/bin/bash', '-c']
          args:
            - |
              # Backwards compatibility change
              if ! [[ -f /opt/bitnami/redis/etc/redis.conf ]]; then
                  echo COPYING FILE
                  cp  /opt/bitnami/redis/etc/redis-default.conf /opt/bitnami/redis/etc/redis.conf
              fi
              pod_index=($(echo "$POD_NAME" | tr "-" "\n"))
              pod_index="${pod_index[-1]}"
              if [[ "$pod_index" == "0" ]]; then
                export REDIS_CLUSTER_CREATOR="yes"
                export REDIS_CLUSTER_REPLICAS="0"
              fi
              /opt/bitnami/scripts/redis-cluster/entrypoint.sh /opt/bitnami/scripts/redis-cluster/run.sh
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: REDIS_NODES
              value: "redis-cluster-0.redis-cluster-headless redis-cluster-1.redis-cluster-headless redis-cluster-2.redis-cluster-headless "
            - name: REDISCLI_AUTH
              valueFrom:
                secretKeyRef:
                  name: redis-cluster
                  key: redis-password
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: redis-cluster
                  key: redis-password
            - name: REDIS_AOF_ENABLED
              value: "yes"
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: tcp-redis
              containerPort: 6379
            - name: tcp-redis-bus
              containerPort: 16379
          livenessProbe:
            initialDelaySeconds: 5
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /scripts/ping_liveness_local.sh 5
          readinessProbe:
            initialDelaySeconds: 5
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /scripts/ping_readiness_local.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: scripts
              mountPath: /scripts
            - name: redis-data
              mountPath: /bitnami/redis/data
              subPath: 
            - name: default-config
              mountPath: /opt/bitnami/redis/etc/redis-default.conf
              subPath: redis-default.conf
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc/
            - mountPath: /redismodules
              name: redismodules
      initContainers:
        - command:
          - sh
          - -c
          - wget https://cloudentity-redisearch.s3.amazonaws.com/redisearch-oss-coord-v2.6.13-amd64.so
            -O /redismodules/redisearch.so && chmod +x /redismodules/redisearch.so
          image: alpine
          name: redismodules
          volumeMounts:
          - mountPath: /redismodules
            name: redismodules
      volumes:
        - name: scripts
          configMap:
            name: redis-cluster-scripts
            defaultMode: 0755
        - name: default-config
          configMap:
            name: redis-cluster-default
        - name: redis-tmp-conf
          emptyDir: {}
        - emptyDir: {}
          name: redismodules
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis-cluster
          app.kubernetes.io/instance: release-name
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/statefulset-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: timescaledb
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: timescaledb
spec:
  serviceName: timescaledb
  replicas: 3
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: timescaledb
      release: release-name
  template:
    metadata:
      name: timescaledb
      labels:
        
        app: timescaledb
        chart: timescaledb-single-0.33.1
        release: release-name
        heritage: Helm
        cluster-name: timescaledb
        app.kubernetes.io/name: "timescaledb"
        app.kubernetes.io/version: 0.33.1
        app.kubernetes.io/component: timescaledb
    spec:
      serviceAccountName: timescaledb
      securityContext:
        # The postgres user inside the TimescaleDB image has uid=1000.
        # This configuration ensures the permissions of the mounts are suitable
        fsGroup: 1000
        runAsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
      initContainers:
      - name: tstune
        securityContext:
          allowPrivilegeEscalation: false
        image: "timescale/timescaledb-ha:pg14.6-ts2.9.1-p1"
        env:
        - name: TSTUNE_FILE
          value: /var/run/postgresql/timescaledb.conf
        - name: WAL_VOLUME_SIZE
          value: 1Gi
        - name: DATA_VOLUME_SIZE
          value: 2Gi
        - name: RESOURCES_CPU_REQUESTS
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: requests.cpu
              divisor: "1"
        - name: RESOURCES_MEMORY_REQUESTS
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: requests.memory
              divisor: 1Mi
        - name: RESOURCES_CPU_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: limits.cpu
              divisor: "1"
        - name: RESOURCES_MEMORY_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: limits.memory
              divisor: 1Mi
        # Command below will run the timescaledb-tune utility and configure min/max wal size based on PVCs size
        command:
          - sh
          - "-c"
          - '/etc/timescaledb/scripts/tstune.sh '
        volumeMounts:
        - name: socket-directory
          mountPath: /var/run/postgresql
        - name: timescaledb-scripts
          mountPath: /etc/timescaledb/scripts
          readOnly: true
        resources:
          
          {}
      # Issuing the final checkpoints on a busy database may take considerable time.
      # Unfinished checkpoints will require more time during startup, so the tradeoff
      # here is time spent in shutdown/time spent in startup.
      # We choose shutdown here, especially as during the largest part of the shutdown
      # we can still serve clients.
      terminationGracePeriodSeconds: 600
      containers:
      - name: timescaledb
        securityContext:
          allowPrivilegeEscalation: false
        image: "timescale/timescaledb-ha:pg14.6-ts2.9.1-p1"
        imagePullPolicy: Always
        lifecycle:
          preStop:
            exec:
              command:
              - psql
              - -X
              - --file
              - "/etc/timescaledb/scripts/lifecycle_preStop.sql"
        # When reusing an already existing volume it sometimes happens that the permissions
        # of the PGDATA and/or wal directory are incorrect. To guard against this, we always correctly
        # set the permissons of these directories before we hand over to Patroni.
        # We also create all the tablespaces that are defined, to ensure a smooth restore/recovery on a
        # pristine set of Volumes.
        # As PostgreSQL requires to have full control over the permissions of the tablespace directories,
        # we create a subdirectory "data" in every tablespace mountpoint. The full path of every tablespace
        # therefore always ends on "/data".
        # By creating a .pgpass file in the $HOME directory, we expose the superuser password
        # to processes that may not have it in their environment (like the preStop lifecycle hook).
        # To ensure Patroni will not mingle with this file, we give Patroni its own pgpass file.
        # As these files are in the $HOME directory, they are only available to *this* container,
        # and they are ephemeral.
        command:
          - /bin/bash
          - "-c"
          - |
            
            install -o postgres -g postgres -d -m 0700 "/var/lib/postgresql/data" "/var/lib/postgresql/wal/pg_wal" || exit 1
            TABLESPACES=""
            for tablespace in ; do
              install -o postgres -g postgres -d -m 0700 "/var/lib/postgresql/tablespaces/${tablespace}/data"
            done

            # Environment variables can be read by regular users of PostgreSQL. Especially in a Kubernetes
            # context it is likely that some secrets are part of those variables.
            # To ensure we expose as little as possible to the underlying PostgreSQL instance, we have a list
            # of allowed environment variable patterns to retain.
            #
            # We need the KUBERNETES_ environment variables for the native Kubernetes support of Patroni to work.
            #
            # NB: Patroni will remove all PATRONI_.* environment variables before starting PostgreSQL

            # We store the current environment, as initscripts, callbacks, archive_commands etc. may require
            # to have the environment available to them
            set -o posix
            export -p > "${HOME}/.pod_environment"
            export -p | grep PGBACKREST > "${HOME}/.pgbackrest_environment"

            for UNKNOWNVAR in $(env | awk -F '=' '!/^(PATRONI_.*|HOME|PGDATA|PGHOST|LC_.*|LANG|PATH|KUBERNETES_SERVICE_.*|AWS_ROLE_ARN|AWS_WEB_IDENTITY_TOKEN_FILE)=/ {print $1}')
            do
                unset "${UNKNOWNVAR}"
            done

            touch /var/run/postgresql/timescaledb.conf
            touch /var/run/postgresql/wal_status

            echo "*:*:*:postgres:${PATRONI_SUPERUSER_PASSWORD}" >> ${HOME}/.pgpass
            chmod 0600 ${HOME}/.pgpass

            export PATRONI_POSTGRESQL_PGPASS="${HOME}/.pgpass.patroni"

            exec patroni /etc/timescaledb/patroni.yaml
        env:
        # We use mixed case environment variables for Patroni User management,
        # as the variable themselves are documented to be PATRONI_<username>_OPTIONS.
        # Where possible, we want to have lowercase usernames in PostgreSQL as more complex postgres usernames
        # requiring quoting to be done in certain contexts, which many tools do not do correctly, or even at all.
        # https://patroni.readthedocs.io/en/latest/ENVIRONMENT.html#bootstrap-configuration
        - name: PATRONICTL_CONFIG_FILE
          value: "/etc/timescaledb/patroni.yaml"
        - name: PATRONI_admin_OPTIONS
          value: createrole,createdb
        - name: PATRONI_REPLICATION_USERNAME
          value: standby
        # To specify the PostgreSQL and Rest API connect addresses we need
        # the PATRONI_KUBERNETES_POD_IP to be available as a bash variable, so we can compose an
        # IP:PORT address later on
        - name: PATRONI_KUBERNETES_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: PATRONI_POSTGRESQL_CONNECT_ADDRESS
          value: "$(PATRONI_KUBERNETES_POD_IP):5432"
        - name: PATRONI_RESTAPI_CONNECT_ADDRESS
          value: "$(PATRONI_KUBERNETES_POD_IP):8008"
        - name: PATRONI_KUBERNETES_PORTS
          value: '[{"name": "postgresql", "port": 5432}]'
        - name: PATRONI_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: PATRONI_POSTGRESQL_DATA_DIR
          value: "/var/lib/postgresql/data"
        - name: PATRONI_KUBERNETES_NAMESPACE
          value: default
        - name: PATRONI_KUBERNETES_LABELS
          value: "{app: timescaledb, cluster-name: timescaledb, release: release-name}"
        - name: PATRONI_SCOPE
          value: timescaledb
        - name: PGBACKREST_CONFIG
          value: /etc/pgbackrest/pgbackrest.conf
        # PGDATA and PGHOST are not required to let Patroni/PostgreSQL run correctly,
        # but for interactive sessions, callbacks and PostgreSQL tools they should be correct.
        - name: PGDATA
          value: "$(PATRONI_POSTGRESQL_DATA_DIR)"
        - name: PGHOST
          value: "/var/run/postgresql"
        - name: WALDIR
          value: "/var/lib/postgresql/wal/pg_wal"
        - name: BOOTSTRAP_FROM_BACKUP
          value: "0"
        - name: PGBACKREST_BACKUP_ENABLED
          value: "false"
        - name: TSTUNE_FILE
          value: /var/run/postgresql/timescaledb.conf
          # pgBackRest is also called using the archive_command if the backup is enabled.
          # this script will also need access to the environment variables specified for
          # the backup. This can be removed once we do not directly invoke pgBackRest
          # from inside the TimescaleDB container anymore
        envFrom:
        - secretRef:
            name: "timescaledb-credentials"
            optional: false
        - secretRef:
            name: "timescaledb-pgbackrest"
            optional: true
        ports:
        - containerPort: 8008
          name: patroni
        - containerPort: 5432
          name: postgresql
        readinessProbe:
          exec:
            command:
              - pg_isready
              - -h
              - /var/run/postgresql
          initialDelaySeconds: 5
          periodSeconds: 30
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 6
        volumeMounts:
        - name: storage-volume
          mountPath: "/var/lib/postgresql"
          subPath: ""
        - name: wal-volume
          mountPath: "/var/lib/postgresql/wal"
          subPath: ""
        - mountPath: /etc/timescaledb/patroni.yaml
          subPath: patroni.yaml
          name: patroni-config
          readOnly: true
        - mountPath: /etc/timescaledb/scripts
          name: timescaledb-scripts
          readOnly: true
        - mountPath: /etc/pgbackrest_secrets
          name: pgbackrest-secrets
          readOnly: true
        - mountPath: "/etc/timescaledb/post_init.d"
          name: post-init
          readOnly: true
        - mountPath: /etc/certificate
          name: certificate
          readOnly: true
        - name: socket-directory
          mountPath: /var/run/postgresql
        
        - mountPath: /etc/pgbackrest
          name: pgbackrest
          readOnly: true
        - mountPath: /etc/pgbackrest/bootstrap
          name: pgbackrest-bootstrap
          readOnly: true
        resources:
          
          {}
      volumes:
      - name: socket-directory
        emptyDir: {}
      - name: patroni-config
        configMap:
          name: timescaledb-patroni
      - name: timescaledb-scripts
        configMap:
          name: timescaledb-scripts
          defaultMode: 488 # 0750 permissions
      
      - name: post-init
        projected:
          defaultMode: 0750
          sources:
            
            - configMap:
                name: custom-init-scripts
                optional: true
            - secret:
                name: custom-secret-scripts
                optional: true
      - name: pgbouncer
        configMap:
          name: timescaledb-pgbouncer
          defaultMode: 416 # 0640 permissions
          optional: true
      - name: pgbackrest
        configMap:
          name: timescaledb-pgbackrest
          defaultMode: 416 # 0640 permissions
          optional: true
      - name: pgbackrest-secrets
        secret:
          secretName: timescaledb-pgbackrest-secrets
          defaultMode: 416
          optional: true
      - name: certificate
        secret:
          secretName: "timescaledb-certificate"
          defaultMode: 416 # 0640 permissions
      - name: pgbackrest-bootstrap
        secret:
          secretName: pgbackrest-bootstrap
          optional: True
  volumeClaimTemplates:
    - metadata:
        name: storage-volume
        annotations:
        labels:
          app: timescaledb
          release: release-name
          heritage: Helm
          cluster-name: timescaledb
          purpose: data-directory
      spec:
        accessModes:
          
        - ReadWriteOnce
        resources:
          requests:
            storage: "2Gi"
    - metadata:
        name: wal-volume
        annotations:
        labels:
          app: timescaledb
          release: release-name
          heritage: Helm
          cluster-name: timescaledb
          purpose: wal-directory
      spec:
        accessModes:
          
        - ReadWriteOnce
        resources:
          requests:
            storage: "1Gi"
---
# Source: kube-acp-stack/charts/cockroachdb/templates/cronjob-client-node-certSelfSigner.yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: cockroachdb-rotate-self-signer-client
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
spec:
  schedule: 0 0 */26 * *
  jobTemplate:
    spec:
      backoffLimit: 1
      template:
        spec:
          restartPolicy: Never
          containers:
          - name: cert-rotate-job
            image: "gcr.io/cockroachlabs-helm-charts/cockroach-self-signer-cert:1.3"
            imagePullPolicy: "IfNotPresent"
            args:
            - rotate
            - --ca-duration=43800h
            - --ca-expiry=648h
            - --client
            - --client-duration=672h
            - --client-expiry=48h
            - --node
            - --node-duration=8760h
            - --node-expiry=168h
            - --node-client-cron=0 0 */26 * *
            - --readiness-wait=30s
            - --pod-update-timeout=2m
            env:
            - name: STATEFULSET_NAME
              value: cockroachdb
            - name: NAMESPACE
              value: default
            - name: CLUSTER_DOMAIN
              value: cluster.local
          serviceAccountName: cockroachdb-rotate-self-signer
---
# Source: kube-acp-stack/charts/acp/templates/ingress.yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: release-name-acp
  labels:
    helm.sh/chart: acp-2.21.0
    app.kubernetes.io/name: acp
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.21.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "8k"
    nginx.ingress.kubernetes.io/proxy-ssl-ciphers: "EECDH+AESGCM:EDH+AESGCM"
    nginx.ingress.kubernetes.io/proxy-ssl-protocols: "TLSv1.2"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-ssl-secret: "default/release-name-acp-tls"
    nginx.ingress.kubernetes.io/proxy-ssl-server-name: "on"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/ssl-ciphers: "EECDH+AESGCM:EDH+AESGCM"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      proxy_set_header X-SSL-CERT "";
    nginx.ingress.kubernetes.io/enable-modsecurity: "true"
    nginx.ingress.kubernetes.io/enable-owasp-core-rules: "true"
    nginx.ingress.kubernetes.io/service-upstream: "true"
spec:
  rules:
    - host: "acp.local"
      http:
        paths:
          - path: /
            backend:
              serviceName: release-name-acp
              servicePort: 8443
---
# Source: kube-acp-stack/charts/acp/templates/tls-secrets.yaml
---
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/configmap-pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/configmap-pgbouncer.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/secret-certificate.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: "timescaledb-certificate"
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: certificates
  annotations:
    "helm.sh/hook": pre-install,post-delete
    "helm.sh/hook-weight": "0"
type: kubernetes.io/tls
stringData:
  tls.crt: "-----BEGIN CERTIFICATE-----\nMIIDFzCCAf+gAwIBAgIQZ2iR8TjJtGwQVJ0O8D7t3TANBgkqhkiG9w0BAQsFADAW\nMRQwEgYDVQQDEwt0aW1lc2NhbGVkYjAeFw0yNDA1MTUwOTUzMTZaFw0yOTA1MTUw\nOTUzMTZaMBYxFDASBgNVBAMTC3RpbWVzY2FsZWRiMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA3GDwtOmiS2xiCKBpTAXOcvsKHpD1uoGzIzajsbb0JDSC\nr9ti+RKmb9Z9Nyd5Rg4IcoHIpR3xe1kzg+1Am8nGio+mLZiyuRV5ozv01nJfMWLk\n4aW4fN39qqKTa0mb9WBuglO2fgNJWbYSGrj2g6usiHsThjjTdSF2TP35CDMo8Nfk\npYgWKVovjMTr7b1cCkKbDHL+T56COpqaMBNoMCap6LZ9yZas7zAkVVWf1fz1oaJP\n5BLczvftMJZFoJJiUY60c7TTeI40XKPz/Z8Mi8EowoggLTip2cN5vbyRGtzJAN2e\nT+GPR0+4OkTy9gIwyMJPI5Mevr5CDAxOt9CYv56iVwIDAQABo2EwXzAOBgNVHQ8B\nAf8EBAMCAqQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMA8GA1UdEwEB\n/wQFMAMBAf8wHQYDVR0OBBYEFP11pnVX/9S8SdhGqphi6yV2Ab2fMA0GCSqGSIb3\nDQEBCwUAA4IBAQAV9knUaHvm77NIaNHMpJDSXxujiZu70Q/vqQkKd/6XW12SD+SA\n1bUKOWRysQZreXGgXyJ2XDbfUv0eA6B39BNnyXiQ6BE1P7ljhU7MaY/ermEa1coN\njdN6mG1RQg6cRSZy7YkAGl7OU8KYYkRpnjFp1QpECTOj17fYvFNYNUzyazhs937D\nIvFB6acfEhSBXJ5FYQ/YA39HjoaAS2gSgAUhezhqs5Pa9ECH8ETRkJO0ggqt+q/R\niZ8awgIoMGSWfsm5eS8sK3NyKwX8ccypPgYtM6SUHPHhZxhvOWzfdnLbeWabz77L\n+v3kCUczwu3BotN2fw/yQhghXX/TcIM5uZX1\n-----END CERTIFICATE-----\n"
  tls.key: "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA3GDwtOmiS2xiCKBpTAXOcvsKHpD1uoGzIzajsbb0JDSCr9ti\n+RKmb9Z9Nyd5Rg4IcoHIpR3xe1kzg+1Am8nGio+mLZiyuRV5ozv01nJfMWLk4aW4\nfN39qqKTa0mb9WBuglO2fgNJWbYSGrj2g6usiHsThjjTdSF2TP35CDMo8NfkpYgW\nKVovjMTr7b1cCkKbDHL+T56COpqaMBNoMCap6LZ9yZas7zAkVVWf1fz1oaJP5BLc\nzvftMJZFoJJiUY60c7TTeI40XKPz/Z8Mi8EowoggLTip2cN5vbyRGtzJAN2eT+GP\nR0+4OkTy9gIwyMJPI5Mevr5CDAxOt9CYv56iVwIDAQABAoIBACjmaOX6kl9THyKg\nusocLcOTKb6ggqp5lciMRHcgEFGD2VlP6x90waTx9s08qzpAMnsl8RoL45xT4say\nSpJfMVTX8ix2MX0+KhQMdZUzJs2gn//s5L9v57s6bwezYpl4qynO5YifjYZzzwpc\nl4u6Wcv+o5H+i+gqLK1/WS+XZxrDboY6U9QZJJUIdzCCYmsxVD02ooTKDIZ167Tm\nYoAPQ8TbE0Ny3x/s+FaiVIiQNINoFnlBiE8cfudR2SwDz1CruJgBMlKuYHXjCFBt\nSmopE2ubAjYYX6T84XoFj5QIwLF1ZV3qjhpT6ZUSBU8zFJCEQv2e3O63dxs3ejaI\nJiDP6UECgYEA7ydyLeqt2Wv5kwqKNZ5JwukV3jYP0hOqOkLCYNuo+D2Y7LoqE7Vb\n0oC6LPUWDsWMcq+SauCVVIloJvrJf66CROlqBCogO3vMnFIPLoMuzgpUzGrY7N2L\nMF7jOwCYEf84lNQ9fXJx2+4/c9y3Rh64PtRwUArwA05+/F+i3izhhfcCgYEA6+bt\nDY2PQW9M3lQrndqU5ubrDcz5j3RnuzFG2rM6/4/9FoLTEQLZ+dGFLVGomYoilEoe\nCU/Wwb3VGYkz4i9O1bXSnzyRDibVp4kYN0lC3fT/XWr5AtrpaX2uxAq6eySfpw7+\n45JbPfUamVyCjM0WQrL889bBz00Ki3zw3eRBLqECgYEAxMxnDxXxXduWksO3nAvX\nkwcPsb43Ip6AFFVfcykPUMgPka5YdcNl/kFj8x7zudAilTWZfU22VMyF4p25NtK5\n7E9PqIGp6IklhPWZ/KKC35Zs1ZKPU8uzgGh1ANaqTRUC0KYeu55zx5G0sXlNb+xT\nnZBfo958R5xOrwtcEQxJwV0CgYBirWg/oRVpk7sdzSupjkN3CuUMEs/ZmCHEBerT\nlOF7Aaomfnb3yK+Rdnk06dGS2Ft6mD5UOtdkl5nKYsAXPx7E+peuEFHFD62TtR8y\nES0tV0xysUqUTSoR/IbcbnhvBnTaFsW8P/52vk5wFGhvqWJEaEazYQQVSO6+Rnci\n+lXhwQKBgQCcSmE/05Kk49vTANKUG212c5DO8YJTMvM7zbgTBkYq6VbWlx25wQN1\n/FUwi+eLrCW057IMZMQdNPXTewPvg6LKb+6H2GsQm8npb1vnzhMIL8t4qWJFxsG1\nRXMjfTBxGy6TKcGsftQTU05jITSBmhpa2n+QVh8y1ek1RwQUH5yB7Q==\n-----END RSA PRIVATE KEY-----\n"
...
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/secret-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: "timescaledb-credentials"
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: patroni
  annotations:
    "helm.sh/hook": pre-install,post-delete
    "helm.sh/hook-weight": "0"
    "helm.sh/resource-policy": keep
type: Opaque
stringData:
  PATRONI_SUPERUSER_PASSWORD: "PaSsW0rD"
  PATRONI_REPLICATION_PASSWORD: "5ndiWTLGTfdbjdC2"
  PATRONI_admin_PASSWORD: "WfGXnwq9uTuB7fJH"
...
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/secret-pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: "timescaledb-pgbackrest"
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: pgbackrest
  annotations:
    "helm.sh/hook": pre-install,post-delete
    "helm.sh/hook-weight": "0"
    "helm.sh/resource-policy": keep
type: Opaque
stringData:
  {}
...
---
# Source: kube-acp-stack/charts/acp/templates/tests/get-access-token.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "release-name-access-token-test"
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: release-name-access-token-test
      image: curlimages/curl
      args: 
        - --insecure
        - --request
        - POST
        - --data
        - grant_type=client_credentials
        - --user
        - system:5c8f3f5b353ba0f55c8f3f5b353ba0f5
        - https://acp.local:8443/system/system/oauth2/token
  restartPolicy: Never
---
# Source: kube-acp-stack/charts/cockroachdb/templates/tests/client.yaml
kind: Pod
apiVersion: v1
metadata:
  name: cockroachdb-test
  namespace: "default"
  annotations:
    helm.sh/hook: test-success
spec:
  restartPolicy: Never
  containers:
    - name: client-test
      image: "cockroachdb/cockroach:v22.2.9"
      imagePullPolicy: "IfNotPresent"
      command:
        - /cockroach/cockroach
        - sql
        - --insecure
        - --host
        - cockroachdb-public.default
        - --port
        - "26257"
        - -e
        - SHOW DATABASES;
---
# Source: kube-acp-stack/charts/cockroachdb/templates/job.init.yaml
kind: Job
apiVersion: batch/v1
metadata:
  name: cockroachdb-init
  namespace: "default"
  labels:
    helm.sh/chart: cockroachdb-10.0.9
    app.kubernetes.io/name: cockroachdb
    app.kubernetes.io/instance: "release-name"
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/component: init
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: before-hook-creation
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: cockroachdb
        app.kubernetes.io/instance: "release-name"
        app.kubernetes.io/component: init
    spec:
      securityContext:
        runAsGroup: 1000
        runAsUser: 1000
        fsGroup: 1000
        runAsNonRoot: true
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 0
      containers:
        - name: cluster-init
          image: "cockroachdb/cockroach:v22.2.9"
          imagePullPolicy: "IfNotPresent"
          # Run the command in an `while true` loop because this Job is bound
          # to come up before the CockroachDB Pods (due to the time needed to
          # get PersistentVolumes attached to Nodes), and sleeping 5 seconds
          # between attempts is much better than letting the Pod fail when
          # the init command does and waiting out Kubernetes' non-configurable
          # exponential back-off for Pod restarts.
          # Command completes either when cluster initialization succeeds,
          # or when cluster has been initialized already.
          command:
          - /bin/bash
          - -c
          - >-
              initCluster() {
                while true; do
                  local output=$(
                    set -x;

                    /cockroach/cockroach init \
                      --insecure \
                      --host=cockroachdb-0.cockroachdb:26257
                  2>&1);

                  local exitCode="$?";
                  echo $output;

                  if [[ "$exitCode" == "0" || "$output" == *"cluster has already been initialized"* ]]
                    then break;
                  fi

                  sleep 5;
                done
              }

              initCluster;
          env:
---
# Source: kube-acp-stack/charts/timescaledb-single/templates/job-update-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: batch/v1
kind: Job
metadata:
  name: "timescaledb-patroni-1"
  namespace: default
  labels:
    
    app: timescaledb
    chart: timescaledb-single-0.33.1
    release: release-name
    heritage: Helm
    cluster-name: timescaledb
    app.kubernetes.io/name: "timescaledb"
    app.kubernetes.io/version: 0.33.1
    app.kubernetes.io/component: patroni
  annotations:
    "helm.sh/hook": post-upgrade
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  activeDeadlineSeconds: 120
  template:
    metadata:
      labels:
        
        app: timescaledb
        chart: timescaledb-single-0.33.1
        release: release-name
        heritage: Helm
        cluster-name: timescaledb
        app.kubernetes.io/name: "timescaledb"
        app.kubernetes.io/version: 0.33.1
    spec:
      restartPolicy: OnFailure
      containers:
      - name: timescaledb-patch-patroni-config
        image: "curlimages/curl:7.87.0"
        imagePullPolicy: Always
        command: ["/bin/sh"]
        # Patching the Patroni configuration is good, however it should not block an upgrade from going through
        # Therefore we ensure we always exit with an exitcode 0, so that Helm is satisfied with this upgrade job
        args:
        - '-c'
        - |
          /usr/bin/curl --connect-timeout 30 --include --request PATCH --data \
          "{\"loop_wait\":10,\"maximum_lag_on_failover\":33554432,\"postgresql\":{\"parameters\":{\"archive_command\":\"/etc/timescaledb/scripts/pgbackrest_archive.sh %p\",\"archive_mode\":\"on\",\"archive_timeout\":\"1800s\",\"autovacuum_analyze_scale_factor\":0.02,\"autovacuum_max_workers\":10,\"autovacuum_naptime\":\"5s\",\"autovacuum_vacuum_cost_limit\":500,\"autovacuum_vacuum_scale_factor\":0.05,\"hot_standby\":\"on\",\"log_autovacuum_min_duration\":\"1min\",\"log_checkpoints\":\"on\",\"log_connections\":\"on\",\"log_disconnections\":\"on\",\"log_line_prefix\":\"%t [%p]: [%c-%l] %u@%d,app=%a [%e] \",\"log_lock_waits\":\"on\",\"log_min_duration_statement\":\"1s\",\"log_statement\":\"ddl\",\"max_connections\":100,\"max_prepared_transactions\":150,\"shared_preload_libraries\":\"timescaledb,pg_stat_statements\",\"ssl\":\"on\",\"ssl_cert_file\":\"/etc/certificate/tls.crt\",\"ssl_key_file\":\"/etc/certificate/tls.key\",\"tcp_keepalives_idle\":900,\"tcp_keepalives_interval\":100,\"temp_file_limit\":\"1GB\",\"timescaledb.passfile\":\"../.pgpass\",\"unix_socket_directories\":\"/var/run/postgresql\",\"unix_socket_permissions\":\"0750\",\"wal_level\":\"hot_standby\",\"wal_log_hints\":\"on\"},\"use_pg_rewind\":true,\"use_slots\":true},\"retry_timeout\":10,\"ttl\":30}" \
          "http://timescaledb-config:8008/config"
          exit 0
